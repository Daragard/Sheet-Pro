<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sheet Pro</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- PDF.js library for rendering PDFs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <style>
        /* Apply the Inter font globally */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
        }
        /* Hide scrollbars for a cleaner app-like look */
        body::-webkit-scrollbar {
            display: none;
        }
        body {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        /* Styling for disabled buttons to indicate their state */
        .button-disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none; /* Disable pointer events on disabled buttons */
        }
        /* Container for the PDF pages */
        .pdf-page-container {
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Hide overflow from scaling */
            position: relative; /* For overlay click areas */
        }
        /* Canvas element styling */
        .pdf-page-canvas {
            width: 100%;
            height: 100%;
            display: block;
            background-color: #fff; /* White background for the canvas */
        }
        /* Clickable overlays for page navigation */
        .page-nav-overlay {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 50%; /* Each overlay takes 50% of its relative parent (pdfViewerContainer) */
            z-index: 5; /* Above canvases, below loading overlay */
            cursor: pointer;
        }
        .page-nav-overlay.left {
            left: 0;
        }
        .page-nav-overlay.right {
            right: 0;
        }
        /* Style for a custom message box */
        #messageBox {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            pointer-events: none;
        }
        #messageBox.active {
            opacity: 1;
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col bg-gray-100 text-gray-800 overflow-hidden">

    <!-- Header Section - Mimicking ForScore's top bar -->
    <header class="flex items-center justify-between p-4 bg-gray-900 text-white shadow-lg z-10">
        <!-- Left group of buttons -->
        <div class="flex items-center space-x-4">
            <!-- Library button restored -->
            <button id="libraryButton" class="flex items-center px-4 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition-colors text-sm font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                <i class="fas fa-book mr-2"></i> Library
            </button>
            <button id="setlistsButton" class="flex items-center px-4 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition-colors text-sm font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                <i class="fas fa-list-alt mr-2"></i> Playlist
            </button>
        </div>

        <!-- App Title in the center -->
        <h1 class="text-2xl font-bold text-indigo-400">Sheet Pro</h1>

        <!-- Right group of buttons -->
        <div class="flex items-center space-x-4">
            <!-- <button id="searchButton" class="flex items-center px-4 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition-colors text-sm font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                <i class="fas fa-search mr-2"></i> Search
            </button>
            <button id="annotateButton" class="flex items-center px-4 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition-colors text-sm font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                <i class="fas fa-pencil-alt mr-2"></i> Annotate
            </button>
            <button id="toolsButton" class="flex items-center px-4 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition-colors text-sm font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                <i class="fas fa-wrench mr-2"></i> Tools
            </button> -->
            <button id="fullscreenToggle" class="flex items-center px-4 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-700 transition-colors text-sm font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                <i class="fas fa-expand-arrows-alt mr-2"></i> Fullscreen
            </button>
        </div>
    </header>

    <!-- Main content area that will handle layout changes based on orientation -->
    <div id="appLayout" class="flex-1 flex flex-col lg:flex-row p-4 gap-4">
        <!-- Setlist Container - Controlled purely by JS now -->
        <div id="setlistContainer" class="w-full lg:w-64 bg-white rounded-xl shadow-lg p-4 overflow-y-auto flex-shrink-0 z-10 transition-all duration-300 ease-in-out hidden">
            <!-- Buttons go here -->
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-gray-700" id="setlistTitle">Setlist</h2>
                <div>
                    <button id="closeSetlistButton" class="text-gray-500 hover:text-gray-700 p-1 rounded-full hover:bg-gray-200">
                        <i class="fas fa-times"></i>
                    </button>
                    <button id="moveSetlistButton" class="text-gray-500 hover:text-gray-700 p-1 rounded-full hover:bg-gray-200 ml-2">
                        <i class="fas fa-exchange-alt"></i>
                    </button>
                </div>
            </div>
            <ul id="setlistItems" class="space-y-2">
                <!-- Setlist items will be dynamically inserted here -->
            </ul>
        </div>

        <!-- Page Info Container - Displays page numbers when setlist is not active -->
        <!-- This container will now always be hidden if not in playlist mode, as per user request -->
        <div id="pageInfoContainer" class="w-full lg:w-64 bg-white rounded-xl shadow-lg p-4 flex-shrink-0 z-10 transition-all duration-300 ease-in-out hidden flex-col items-center justify-center text-gray-700 text-2xl font-bold">
            <span id="currentPageOfTotal"></span>
        </div>

        <!-- Main PDF Viewer Area -->
        <main id="pdfMainContent" class="flex-1 flex flex-col items-center justify-center relative z-20">
            <div class="bg-white rounded-xl shadow-lg w-full h-full overflow-hidden flex flex-col p-4">
                <!-- PDF Viewer Canvases and Loading Overlay -->
                <!-- Justify to start or end will be controlled by JS. No middle page anymore. -->
                <div id="pdfViewerContainer" class="flex-1 flex items-stretch relative gap-x-0 flex-nowrap justify-center">
                    <!-- Left Page Container (always visible if any page is rendered) -->
                    <div id="pdfPageLeftContainer" class="pdf-page-container flex-shrink-0">
                        <canvas id="pdfCanvasLeft" class="pdf-page-canvas"></canvas>
                    </div>
                    <!-- Right Page Container (shown for 2-page view) -->
                    <div id="pdfPageRightContainer" class="pdf-page-container flex-shrink-0 hidden">
                        <canvas id="pdfCanvasRight" class="pdf-page-canvas"></canvas>
                    </div>

                    <!-- Navigation Overlays (moved outside of pdfPageContainers to always be active) -->
                    <div id="leftNavOverlay" class="page-nav-overlay left"></div>
                    <div id="rightNavOverlay" class="page-nav-overlay right"></div>

                    <!-- Loading Overlay -->
                    <div id="loadingOverlay" class="absolute inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center text-white text-xl rounded-xl transition-opacity duration-300 opacity-0 pointer-events-none">
                        <i class="fas fa-spinner fa-spin mr-2"></i> Loading PDF...
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Message box for user feedback -->
    <div id="messageBox" class="fixed bottom-8 left-4 right-4 bg-gray-800 text-white px-6 py-3 rounded-lg shadow-lg opacity-0 transition-opacity duration-300 pointer-events-none z-50">
    </div>

    <!-- Collapsible Aside for Library - Restored -->
    <aside id="libraryAside" class="fixed top-0 left-0 h-screen w-64 bg-gray-800 text-white shadow-xl z-20 transform -translate-x-full transition-transform duration-300 ease-in-out flex flex-col">
        <div class="p-4 flex items-center justify-between border-b border-gray-700">
            <h2 class="text-xl font-bold">Library</h2>
            <button id="closeAsideButton" class="text-gray-400 hover:text-white transition-colors">
                <i class="fas fa-times text-2xl"></i>
            </button>
        </div>
        <div class="flex-1 overflow-y-auto p-4">
            <h3 class="text-lg font-semibold mb-2 text-indigo-300">Artists</h3>
            <ul class="mb-4 space-y-1">
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Ludwig van Beethoven</a></li>
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Wolfgang Amadeus Mozart</a></li>
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Johann Sebastian Bach</a></li>
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Frédéric Chopin</a></li>
            </ul>

            <h3 class="text-lg font-semibold mb-2 text-indigo-300">Genres</h3>
            <ul class="mb-4 space-y-1">
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Classical</a></li>
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Romantic</a></li>
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Baroque</a></li>
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Jazz</a></li>
            </ul>

            <h3 class="text-lg font-semibold mb-2 text-indigo-300">Collections</h3>
            <ul class="space-y-1">
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">My Favorites</a></li>
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Practice Pieces</a></li>
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Performance Repertoire</a></li>
            </ul>
        </div>
    </aside>

    <script>
        // Set up the PDF.js worker source
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        // Select elements from the DOM
        const body = document.body;
        const messageBox = document.getElementById('messageBox');
        const fullscreenToggle = document.getElementById('fullscreenToggle');
        const libraryButton = document.getElementById('libraryButton');
        const setlistsButton = document.getElementById('setlistsButton');
        const libraryAside = document.getElementById('libraryAside');
        const closeAsideButton = document.getElementById('closeAsideButton');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const pdfViewerContainer = document.getElementById('pdfViewerContainer');
        const setlistContainer = document.getElementById('setlistContainer');
        const closeSetlistButton = document.getElementById('closeSetlistButton');
        const moveSetlistButton = document.getElementById('moveSetlistButton');
        const appLayout = document.getElementById('appLayout');
        const setlistTitleElement = document.getElementById('setlistTitle'); // Still used for the main title
        const setlistItemsUl = document.getElementById('setlistItems');

        // New elements for page number display
        const pageInfoContainer = document.getElementById('pageInfoContainer');
        const currentPageOfTotalSpan = document.getElementById('currentPageOfTotal');


        const pdfCanvasLeft = document.getElementById('pdfCanvasLeft');
        const pdfContextLeft = pdfCanvasLeft.getContext('2d');
        const pdfCanvasRight = document.getElementById('pdfCanvasRight');
        const pdfContextRight = pdfCanvasRight.getContext('2d');

        const pdfPageLeftContainer = document.getElementById('pdfPageLeftContainer');
        const pdfPageRightContainer = document.getElementById('pdfPageRightContainer');

        const leftNavOverlay = document.getElementById('leftNavOverlay');
        const rightNavOverlay = document.getElementById('rightNavOverlay');

        // Get all buttons that are NOT inside the libraryAside for disabling
        const allButtons = Array.from(document.querySelectorAll('button'));
        const nonAsideButtons = allButtons.filter(button => !libraryAside.contains(button));


        let pdfDoc = null;
        let currentPageNum = 1;
        let isSetlistReversed = false;
        let previousOrientationIsPortrait = window.innerHeight > window.innerWidth;
        let isSetlistOpen; // Initialized in initializeSetlist
        let currentViewableSetlistSongs = []; // Array of song objects for the current playlist
        let currentSongIndexInPlaylist = -1; // Index of the currently displayed song in currentViewableSetlistSongs
        let currentPlayingPlaylistName = ''; // Name of the currently playing playlist
        let isPlaylistActive = false; // New flag to indicate if a playlist is being played

        let renderTaskLeft = null;
        let renderTaskRight = null;
        let currentPdfUrl = null; // Track the currently loaded PDF URL


        /**
         * Displays a temporary message box to the user.
         * @param {string} message - The message to display.
         * @param {number} duration - How long the message should be visible in milliseconds.
         */
        function showMessage(message, duration = 3000) {
            messageBox.textContent = message;
            messageBox.classList.remove('opacity-0');
            messageBox.classList.add('opacity-100');
            setTimeout(() => {
                messageBox.classList.remove('opacity-100');
                messageBox.classList.add('opacity-0');
            }, duration);
        }

        /**
         * Removes the file extension from a given filename string.
         * @param {string} filename - The filename with or without an extension.
         * @returns {string} The filename without its extension.
         */
        function removeFileExtension(filename) {
            const lastDotIndex = filename.lastIndexOf('.');
            if (lastDotIndex === -1) {
                return filename; // No extension found
            }
            if (lastDotIndex === 0 || lastDotIndex === filename.length - 1) {
                return filename;
            }
            return filename.substring(0, lastDotIndex);
        }

        /**
         * Shows or hides the loading overlay.
         * @param {boolean} isLoading - True to show, false to hide.
         */
        function showLoading(isLoading) {
            if (isLoading) {
                loadingOverlay.classList.remove('opacity-0', 'pointer-events-none');
                loadingOverlay.classList.add('opacity-100');
            } else {
                loadingOverlay.classList.remove('opacity-100');
                loadingOverlay.classList.add('opacity-0', 'pointer-events-none');
            }
        }

        /**
         * Renders a specific PDF page onto a given canvas.
         * @param {object} pdfPage - The PDF page object from PDF.js.
         * @param {HTMLCanvasElement} canvas - The canvas element to render on.
         * @param {CanvasRenderingContext2D} context - The 2D rendering context of the canvas.
         * @param {string} canvasId - 'left' or 'right' to track the render task.
         * @param {number} totalPagesDisplayed - The total number of pages currently being displayed (1 or 2).
         */
        async function renderPage(pdfPage, canvas, context, canvasId, totalPagesDisplayed) {
            // Cancel any existing render task for this canvas
            if (canvasId === 'left' && renderTaskLeft) {
                renderTaskLeft.cancel();
                renderTaskLeft = null;
            } else if (canvasId === 'right' && renderTaskRight) {
                renderTaskRight.cancel();
                renderTaskRight = null;
            }

            // Get viewport for the page at a base scale
            const viewport = pdfPage.getViewport({ scale: 1 });

            // Get current dimensions of the pdfViewerContainer (parent of pdfPageContainers)
            const availableViewerWidth = pdfViewerContainer.clientWidth;
            const availableViewerHeight = pdfViewerContainer.clientHeight;

            // Calculate maximum available width and height for a single page based on totalPagesDisplayed
            const maxPageWidth = availableViewerWidth / totalPagesDisplayed;
            const maxPageHeight = availableViewerHeight;

            // Calculate scale to fit the page into its calculated slot, maintaining aspect ratio
            const scaleX = maxPageWidth / viewport.width;
            const scaleY = maxPageHeight / viewport.height;
            const renderScale = Math.min(scaleX, scaleY);

            const scaledViewport = pdfPage.getViewport({ scale: renderScale });

            const resolutionScale = window.devicePixelRatio || 1;

            canvas.width = scaledViewport.width * resolutionScale;
            canvas.height = scaledViewport.height * resolutionScale;

            // Set the *CSS* dimensions of the canvas element.
            canvas.style.width = scaledViewport.width + 'px';
            canvas.style.height = scaledViewport.height + 'px';

            // Set the dimensions of the parent container to match the canvas dimensions
            // This is crucial to make the container snug around the rendered PDF content
            canvas.parentElement.style.width = scaledViewport.width + 'px';
            canvas.parentElement.style.height = scaledViewport.height + 'px';

            context.scale(resolutionScale, resolutionScale);

            const renderContext = {
                canvasContext: context,
                viewport: scaledViewport,
            };

            // Store the render task
            const renderTask = pdfPage.render(renderContext);
            if (canvasId === 'left') {
                renderTaskLeft = renderTask;
            } else if (canvasId === 'right') {
                renderTaskRight = renderTask;
            }

            try {
                await renderTask.promise;
            } catch (error) {
                // Ignore render cancellation errors
                if (error.name === 'RenderingCancelledException') {
                    console.log(`Render for ${canvasId} cancelled.`);
                } else {
                    console.error(`Error rendering ${canvasId} page:`, error);
                    throw error; // Re-throw other errors
                }
            } finally {
                // Clear the task reference after completion or cancellation
                if (canvasId === 'left') {
                    renderTaskLeft = null;
                } else if (canvasId === 'right') {
                    renderTaskRight = null;
                }
                context.setTransform(1, 0, 0, 1, 0, 0); // Reset context transform
            }
        }

        /**
         * Renders PDF pages based on current page number and screen orientation.
         */
        async function renderPdfPages() {
            if (!pdfDoc) {
                // If no PDF is loaded, ensure both containers are hidden and page info is cleared
                setlistContainer.classList.add('hidden');
                pageInfoContainer.classList.add('hidden');
                currentPageOfTotalSpan.textContent = '';
                return;
            }

            showLoading(true);

            // Clear canvases before rendering new pages
            pdfContextLeft.clearRect(0, 0, pdfCanvasLeft.width, pdfCanvasLeft.height);
            pdfContextRight.clearRect(0, 0, pdfCanvasRight.width, pdfCanvasRight.height);

            const currentIsPortrait = window.innerHeight > window.innerWidth;

            let numPagesToDisplay = 1; // Default to 1 page mode
            if (!currentIsPortrait && pdfDoc.numPages >= 2) {
                numPagesToDisplay = 2; // 2-page mode in landscape if at least 2 pages exist
            }

            // Adjust currentPageNum based on orientation change and number of pages to display
            let targetFirstVisiblePage = currentPageNum;
            if (previousOrientationIsPortrait && !currentIsPortrait) { // Portrait to Landscape
                if (numPagesToDisplay === 2) {
                    // If moving to 2-page mode and current page is even, shift to previous odd page
                    if (currentPageNum % 2 === 0 && currentPageNum > 1) {
                        targetFirstVisiblePage = currentPageNum - 1;
                    }
                }
            }
            // Ensure currentPageNum doesn't go below 1 or beyond what's available
            currentPageNum = Math.max(1, Math.min(targetFirstVisiblePage, pdfDoc.numPages - numPagesToDisplay + 1));
            previousOrientationIsPortrait = currentIsPortrait;

            // Handle setlist and pageInfoContainer visibility based on orientation and isPlaylistActive state
            if (!currentIsPortrait && isPlaylistActive) { // Landscape and playlist active
                setlistContainer.classList.remove('hidden');
                pageInfoContainer.classList.add('hidden'); // Hide page info when setlist is shown
            } else { // Portrait OR not in playlist mode (single song)
                setlistContainer.classList.add('hidden');
                pageInfoContainer.classList.add('hidden'); // Always hide both if not in playlist mode or if in portrait
            }


            // Adjust justify-content to center for all page display modes
            pdfViewerContainer.classList.add('justify-center');
            pdfViewerContainer.classList.remove('justify-start', 'justify-end');

            // Hide all potential pages first, then show what's needed
            pdfPageLeftContainer.style.display = 'none';
            pdfPageRightContainer.style.display = 'none';

            try {
                // Always render the first page in the current view
                if (pdfDoc.numPages >= currentPageNum) {
                    pdfPageLeftContainer.style.display = 'flex';
                    await renderPage(await pdfDoc.getPage(currentPageNum), pdfCanvasLeft, pdfContextLeft, 'left', numPagesToDisplay);
                }

                // Render second page (if 2-page mode)
                if (numPagesToDisplay === 2 && pdfDoc.numPages >= currentPageNum + 1) {
                    pdfPageRightContainer.style.display = 'flex';
                    await renderPage(await pdfDoc.getPage(currentPageNum + 1), pdfCanvasRight, pdfContextRight, 'right', numPagesToDisplay);
                }

            } catch (error) {
                console.error('Error rendering PDF pages:', error);
                showMessage('Error rendering PDF pages. Please try again.', 5000);
            } finally {
                showLoading(false);
            }
        }

        /**
         * Loads a PDF document from a given URL.
         * @param {string} url - The URL of the PDF document.
         */
        async function loadPdf(url) {
            showLoading(true);
            try {
                if (renderTaskLeft) { renderTaskLeft.cancel(); renderTaskLeft = null; }
                if (renderTaskRight) { renderTaskRight.cancel(); renderTaskRight = null; }

                pdfDoc = await pdfjsLib.getDocument(url).promise;
                currentPageNum = 1;
                currentPdfUrl = url; // Store the URL of the successfully loaded PDF
                
                await renderPdfPages();
                showMessage('PDF loaded successfully!');
            } catch (error) {
                console.error('Error loading PDF:', error);
                // Display specific error message instead of falling back to default PDF
                showMessage('Error: Could not load PDF. Please ensure the file exists on the server or the path is correct.', 5000);
                pdfDoc = null; // Ensure pdfDoc is null if loading failed
            } finally {
                showLoading(false);
            }
        }

        /**
         * Toggles fullscreen mode for the document.
         */
        function toggleFullscreen() {
            // Check if libraryAside is open, and if so, prevent fullscreen until it's closed
            if (libraryAside.classList.contains('translate-x-0')) {
                showMessage("Please close the Library panel before entering fullscreen mode.", 3000);
                return;
            }

            if (!document.fullscreenElement &&
                !document.webkitFullscreenElement &&
                !document.mozFullScreenElement &&
                !document.msFullscreenElement) {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen().catch(err => {
                        showMessage(`Error entering fullscreen: ${err.message}`, 5000);
                        console.error("Error attempting to enable full-screen mode:", err);
                    });
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen().catch(err => {
                        showMessage(`Error entering fullscreen: ${err.message}`, 5000);
                        console.error("Error attempting to enable full-screen mode (webkit):", err);
                    });
                } else if (document.documentElement.msRequestFullscreen) {
                    document.documentElement.msRequestFullscreen().catch(err => {
                        showMessage(`Error entering fullscreen: ${err.message}`, 5000);
                        console.error("Error attempting to enable full-screen mode (ms):", err);
                    });
                } else {
                    showMessage("Fullscreen mode is not supported by your browser.", 5000);
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        // Add event listener to the fullscreen toggle button
        fullscreenToggle.addEventListener('click', toggleFullscreen);

        // Event listeners for fullscreen changes to re-render PDF pages
        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                showMessage("Entered fullscreen mode!");
            } else {
                showMessage("Exited fullscreen mode.");
            }
            setTimeout(() => {
                if (pdfDoc) {
                    renderPdfPages();
                }
            }, 50);
        });
        document.addEventListener('webkitfullscreenchange', () => {
            if (document.webkitFullscreenElement) {
                showMessage("Entered fullscreen mode!");
            } else {
                showMessage("Exited fullscreen mode.");
            }
            setTimeout(() => {
                if (pdfDoc) {
                    renderPdfPages();
                }
            }, 50);
        });
        document.addEventListener('msfullscreenchange', () => {
            if (document.msFullscreenElement) {
                showMessage("Entered fullscreen mode!");
            } else {
                showMessage("Exited fullscreen mode.");
            }
            setTimeout(() => {
                if (pdfDoc) {
                    renderPdfPages();
                }
            }, 50);
        });

        /**
         * Disables/enables buttons that are not part of the library aside.
         * @param {boolean} disabled - True to disable, false to enable.
         */
        function setNonAsideButtonsState(disabled) {
            nonAsideButtons.forEach(button => {
                button.disabled = disabled;
                if (disabled) {
                    button.classList.add('button-disabled');
                } else {
                    button.classList.remove('button-disabled');
                }
            });
            if (disabled) {
                // Ensure other interactive areas are disabled too, e.g., the PDF navigation overlays
                pdfViewerContainer.classList.add('pointer-events-none');
            } else {
                pdfViewerContainer.classList.remove('pointer-events-none');
            }
        }

        /**
         * Toggles the visibility of the library aside (the sliding panel).
         * @param {boolean} [show] - Optional. True to show, false to hide. If omitted, it toggles the current state.
         */
        function toggleAside(show) {
            if (show === true) {
                libraryAside.classList.remove('-translate-x-full');
                libraryAside.classList.add('translate-x-0');
                setNonAsideButtonsState(true); // Disable buttons when aside opens
            } else if (show === false) {
                libraryAside.classList.remove('translate-x-0');
                libraryAside.classList.add('-translate-x-full');
                setNonAsideButtonsState(false); // Enable buttons when aside closes
            } else { // Toggle if 'show' is undefined
                const isAsideOpen = libraryAside.classList.contains('translate-x-0');
                if (isAsideOpen) {
                    toggleAside(false);
                } else {
                    toggleAside(true);
                }
            }
        }

        // Add event listener to the "Library" button to open the library aside
        libraryButton.addEventListener('click', () => {
            // Redirect to library.html
            window.location.href = 'library.html';
        });

        // Add event listener to the close button inside the library aside
        closeAsideButton.addEventListener('click', () => toggleAside(false));

        // Event listener for clicks anywhere on the document to close the library aside if open and click is outside
        document.addEventListener('click', (event) => {
            const isClickInsideAside = libraryAside.contains(event.target);
            const isLibraryButton = event.target === libraryButton || libraryButton.contains(event.target);

            if (libraryAside.classList.contains('translate-x-0') && !isClickInsideAside && !isLibraryButton) {
                toggleAside(false);
            }
        });

        setlistsButton.addEventListener('click', () => {
            isSetlistOpen = !isSetlistOpen;
            if (pdfDoc) {
                renderPdfPages(); // Re-render to show/hide setlist based on new state
            }
        });

        closeSetlistButton.addEventListener('click', () => {
            setlistContainer.classList.add('hidden');
            isSetlistOpen = false;
            if (pdfDoc) {
                renderPdfPages();
            }
        });

        moveSetlistButton.addEventListener('click', () => {
            const currentIsPortrait = window.innerHeight > window.innerWidth;

            if (currentIsPortrait) {
                appLayout.classList.toggle('flex-col-reverse');
            } else {
                appLayout.classList.toggle('lg:flex-row-reverse');
            }
            isSetlistReversed = !isSetlistReversed;
        });

        leftNavOverlay.addEventListener('click', async () => {
            if (!pdfDoc) {
                showMessage("No PDF loaded.", 2000);
                return;
            }
            console.log(`[LeftNav] Clicked. Current state:
                isPlaylistActive: ${isPlaylistActive}
                currentSongIndexInPlaylist: ${currentSongIndexInPlaylist}
                currentViewableSetlistSongs.length: ${currentViewableSetlistSongs.length}
                currentPageNum: ${currentPageNum}
                pdfDoc.numPages: ${pdfDoc.numPages}`);

            const currentIsPortrait = window.innerHeight > window.innerWidth;
            let step = 1;

            let currentPagesToDisplay = 1;
            if (!currentIsPortrait && pdfDoc.numPages >= 2) {
                currentPagesToDisplay = 2;
            }
            step = currentPagesToDisplay;

            // If not on the first page of the current PDF, just go back pages
            if (currentPageNum > 1) {
                currentPageNum = Math.max(1, currentPageNum - step);
                console.log(`[LeftNav] Going back page. New currentPageNum: ${currentPageNum}`);
                await renderPdfPages(); // Await the rendering
            } else if (isPlaylistActive && currentSongIndexInPlaylist > 0) {
                // If on the first page AND a playlist is active AND there's a previous song
                currentSongIndexInPlaylist--;
                const prevSong = currentViewableSetlistSongs[currentSongIndexInPlaylist];
                if (prevSong && prevSong.file_path) {
                    showMessage(`Playing previous song: ${prevSong.name}`, 2000);
                    // No need to update last played date for previous song
                    await loadPdf(`/local_pdfs/${prevSong.file_path}`);
                    renderSetlist(); // Re-render setlist to highlight current song
                } else {
                    showMessage(`Could not load previous song "${prevSong.name}". File path missing.`, 3000);
                    console.error("Previous song in playlist missing file_path or invalid:", prevSong);
                }
            } else {
                showMessage("You are on the first page(s) or at the beginning of the playlist.", 2000);
            }
        });

        rightNavOverlay.addEventListener('click', async () => {
            if (!pdfDoc) {
                showMessage("No PDF loaded.", 2000);
                return;
            }
            console.log(`[RightNav] Clicked. Current state:
                isPlaylistActive: ${isPlaylistActive}
                currentSongIndexInPlaylist: ${currentSongIndexInPlaylist}
                currentViewableSetlistSongs.length: ${currentViewableSetlistSongs.length}
                currentPageNum: ${currentPageNum}
                pdfDoc.numPages: ${pdfDoc.numPages}`);

            const currentIsPortrait = window.innerHeight > window.innerWidth;
            let step = 1;

            let currentPagesToDisplay = 1;
            if (!currentIsPortrait && pdfDoc.numPages >= 2) {
                currentPagesToDisplay = 2;
            }
            step = currentPagesToDisplay;

            // If advancing pages within the current PDF
            // Check if the *last page of the next set* is within bounds
            if (currentPageNum + step - 1 < pdfDoc.numPages) { 
                currentPageNum = currentPageNum + step;
                // Ensure it doesn't go beyond the last possible starting page for a set of 'step' pages
                currentPageNum = Math.min(currentPageNum, pdfDoc.numPages - (step - 1));
                console.log(`[RightNav] Advancing page. New currentPageNum: ${currentPageNum}`);
                await renderPdfPages(); // Await the rendering
            } else if (isPlaylistActive && currentSongIndexInPlaylist !== -1 && currentSongIndexInPlaylist < currentViewableSetlistSongs.length - 1) {
                // If on the last page of current PDF AND a playlist is active AND there's a next song
                currentSongIndexInPlaylist++;
                const nextSong = currentViewableSetlistSongs[currentSongIndexInPlaylist];
                if (nextSong && nextSong.file_path) {
                    showMessage(`Playing next song: ${nextSong.name}`, 2000);
                    // Update the last played date for the *new* song
                    fetch(`/api/library/${nextSong.id}/play`, { method: 'POST' })
                        .then(res => res.json())
                        .then(data => console.log(data.message || data.error))
                        .catch(error => console.error("Error updating play date for next song:", error));

                    await loadPdf(`/local_pdfs/${nextSong.file_path}`);
                    renderSetlist(); // Re-render setlist to highlight current song
                } else {
                    showMessage(`Could not load next song "${nextSong.name}". File path missing.`, 3000);
                    console.error("Next song in playlist missing file_path or invalid:", nextSong);
                }
            } else {
                showMessage("You are on the last page(s) or at the end of the playlist.", 2000);
            }
        });

        // Event listener for window resize to re-render PDF pages and adjust layout
        window.addEventListener('resize', () => {
            if (pdfDoc) {
                renderPdfPages();
            }
            const currentIsPortrait = window.innerHeight > window.innerWidth;
            if (isSetlistReversed) {
                if (currentIsPortrait) {
                    appLayout.classList.add('flex-col-reverse');
                    appLayout.classList.remove('lg:flex-row-reverse');
                } else {
                    appLayout.classList.remove('flex-col-reverse');
                    appLayout.classList.add('lg:flex-row-reverse');
                }
            } else {
                appLayout.classList.remove('flex-col-reverse');
                appLayout.classList.remove('lg:flex-row-reverse');
            }
        });

        /**
         * Initializes the setlist panel by fetching song details from localStorage
         * and populating the setlist UI.
         */
        async function initializeSetlist() {
            console.log("[Setlist Init] Initializing setlist.");
            const playlistSongsQueueJSON = localStorage.getItem('playlistSongsQueue');
            currentPlayingPlaylistName = localStorage.getItem('currentPlayingPlaylistName') || 'Current Playlist';
            
            // Determine if a playlist is active based on the presence of playlistSongsQueue
            isPlaylistActive = !!playlistSongsQueueJSON;

            const storedSetlistOpen = localStorage.getItem('isSetlistOpen');
            // isSetlistOpen should only be true if a playlist is active AND it was previously open
            isSetlistOpen = (storedSetlistOpen === 'true' && isPlaylistActive); 

            const storedSetlistReversed = localStorage.getItem('isSetlistReversed');
            isSetlistReversed = (storedSetlistReversed === 'true');

            const currentIsPortrait = window.innerHeight > window.innerWidth;
            if (isSetlistReversed) {
                if (currentIsPortrait) {
                    appLayout.classList.add('flex-col-reverse');
                } else {
                    appLayout.classList.add('lg:flex-row-reverse');
                }
            }

            if (isPlaylistActive) {
                console.log("[Setlist Init] playlistSongsQueue found in localStorage. Setting isPlaylistActive to true.");
                
                // Show setlist if in landscape and it was previously open
                if (isSetlistOpen && !currentIsPortrait) {
                    setlistContainer.classList.remove('hidden');
                    pageInfoContainer.classList.add('hidden'); // Hide page info container
                } else { // Hide setlist if portrait or not open
                    setlistContainer.classList.add('hidden');
                    pageInfoContainer.classList.add('hidden'); // Also hide page info container
                }
                
                const songIds = JSON.parse(playlistSongsQueueJSON);
                const fetchedSongs = [];

                for (const songId of songIds) {
                    console.log(`[Setlist Init] Fetching details for song ID: ${songId}`);
                    try {
                        const response = await fetch(`/api/library/${songId}`);
                        if (response.ok) {
                            const songDetails = await response.json();
                            fetchedSongs.push(songDetails);
                            console.log(`[Setlist Init] Fetched song details for ID ${songId}: Name: ${songDetails.name}, File Path: ${songDetails.file_path}`); // Added file_path to log
                        } else {
                            console.warn(`[Setlist Init] Failed to fetch details for song ID ${songId}. Status: ${response.status}`);
                            fetchedSongs.push({ id: songId, name: `Unknown Song ${songId}`, title: `Unknown Song ${songId}`, file_path: null }); // Ensure file_path is explicitly null
                        }
                    } catch (error) {
                        console.error(`[Setlist Init] Error fetching song details for ID ${songId}:`, error);
                        fetchedSongs.push({ id: songId, name: `Error Loading Song ${songId}`, title: `Error Loading Song ${songId}`, file_path: null }); // Ensure file_path is explicitly null
                    }
                }
                currentViewableSetlistSongs = fetchedSongs;
                renderSetlist();

                // Determine the initial song to load if a playlist is active
                const songToPlayFromPlaylistId = localStorage.getItem('songToPlayFromPlaylistId');
                if (songToPlayFromPlaylistId) {
                    // Find the index of the specific song requested
                    currentSongIndexInPlaylist = currentViewableSetlistSongs.findIndex(song => song.id == songToPlayFromPlaylistId);
                    localStorage.removeItem('songToPlayFromPlaylistId'); // Clear the flag
                } else {
                    // If no specific song was requested, default to the first song in the playlist
                    currentSongIndexInPlaylist = 0;
                }

                // Load the determined initial song from the playlist
                console.log(`[Setlist Init DEBUG] Before initial song load check: currentSongIndexInPlaylist=${currentSongIndexInPlaylist}, currentViewableSetlistSongs[currentSongIndexInPlaylist]=`, currentViewableSetlistSongs[currentSongIndexInPlaylist]);
                if (currentSongIndexInPlaylist !== -1 && currentViewableSetlistSongs[currentSongIndexInPlaylist]) { // Removed .file_path check here, as loadPdf handles it
                    const initialSong = currentViewableSetlistSongs[currentSongIndexInPlaylist];
                    console.log(`[Setlist Init] Attempting to load initial song: ${initialSong.name}, file_path: ${initialSong.file_path}`); // Added log
                    if (initialSong.file_path) { // Perform file_path check before loading
                        await loadPdf(`/local_pdfs/${initialSong.file_path}`);
                        renderSetlist(); // Re-render to highlight the initially loaded song
                    } else {
                        showMessage(`Could not load the first song in the playlist ("${initialSong.name}"). File path missing.`, 5000);
                        console.error("[Setlist Init] Initial playlist song missing file_path:", initialSong);
                        pdfDoc = null; // Ensure pdfDoc is null
                        pdfContextLeft.clearRect(0, 0, pdfCanvasLeft.width, pdfCanvasLeft.height);
                        pdfContextRight.clearRect(0, 0, pdfCanvasRight.width, pdfCanvasRight.height);
                        showLoading(false); // Ensure loading overlay is hidden
                    }
                } else {
                    showMessage("Could not load the first song in the playlist. Playlist is empty or song index is invalid.", 5000);
                    console.error("[Setlist Init] Initial playlist song missing or invalid index.");
                    // If the first song fails, do NOT load a default PDF. Keep it blank or show error.
                    pdfDoc = null; // Ensure pdfDoc is null
                    pdfContextLeft.clearRect(0, 0, pdfCanvasLeft.width, pdfCanvasLeft.height);
                    pdfContextRight.clearRect(0, 0, pdfCanvasRight.width, pdfCanvasRight.height);
                    showLoading(false); // Ensure loading overlay is hidden
                }

            } else {
                console.log("[Setlist Init] No playlistSongsQueue found. Hiding setlist and setting isPlaylistActive to false.");
                setlistContainer.classList.add('hidden');
                isSetlistOpen = false;
                localStorage.setItem('isSetlistOpen', isSetlistOpen);
                // If no playlist is active, ensure currentSongIndexInPlaylist is reset
                currentSongIndexInPlaylist = -1; 
                // Always hide page info container if not in playlist mode
                pageInfoContainer.classList.add('hidden'); 
            }
            console.log("[Setlist Init] Setlist initialization complete. Final isSetlistOpen:", isSetlistOpen, "isPlaylistActive:", isPlaylistActive);
            if (pdfDoc) {
                renderPdfPages();
            }
        }

        /**
         * Renders the songs currently in `currentViewableSetlistSongs` into the setlist panel UI.
         */
        function renderSetlist() {
            console.log("[Setlist Render] Rendering setlist items.");
            setlistItemsUl.innerHTML = '';
            setlistTitleElement.textContent = currentPlayingPlaylistName;

            if (currentViewableSetlistSongs.length === 0) {
                setlistItemsUl.innerHTML = '<li class="p-2 text-gray-500">No songs in playlist.</li>';
                console.log("[Setlist Render] Setlist is empty.");
                return;
            }

            currentViewableSetlistSongs.forEach((song, index) => {
                const li = document.createElement('li');
                li.className = 'p-2 rounded-md hover:bg-gray-200 cursor-pointer text-gray-800';
                if (index === currentSongIndexInPlaylist) {
                    li.classList.add('bg-indigo-200', 'font-semibold'); // Highlight current song
                }
                const displayTitle = song.title || removeFileExtension(song.name);
                const displayComposer = song.composer ? ` (${song.composer})` : '';
                li.textContent = `${displayTitle}${displayComposer}`;
                li.dataset.songId = song.id;
                // Make sure to store the full path for PDF.js to use
                li.dataset.filePath = song.file_path ? `/local_pdfs/${song.file_path}` : ''; // Ensure file_path exists

                li.addEventListener('click', () => {
                    console.log(`[Setlist Item Click] Clicked song: ${song.name}, ID: ${song.id}, FilePath: ${li.dataset.filePath}`);
                    if (li.dataset.filePath) { // Check if filePath is valid
                        currentSongIndexInPlaylist = index; // Update current song index
                        if (currentPdfUrl === li.dataset.filePath) { // Check if the same PDF is already loaded
                            currentPageNum = 1;
                            console.log("[Setlist Item Click] PDF already loaded. Resetting to page 1.");
                            renderPdfPages();
                        } else {
                            console.log("[Setlist Item Click] Loading new PDF.");
                            loadPdf(li.dataset.filePath);
                        }
                        renderSetlist(); // Re-render to update highlight
                    } else {
                        showMessage(`PDF path not found for "${displayTitle}".`, 3000);
                        console.error(`[Setlist Item Click] PDF path missing for song ID: ${song.id}`);
                    }
                });
                setlistItemsUl.appendChild(li);
            });
            console.log("[Setlist Render] Setlist items rendered.");
        }


        // Automatic PDF load on app startup and render initial state of setlist
        document.addEventListener('DOMContentLoaded', async () => {
            console.log("[DOMContentLoaded] App starting up.");
            const songToPlayFromPlaylistId = localStorage.getItem('songToPlayFromPlaylistId');
            const playlistSongsQueueJSON = localStorage.getItem('playlistSongsQueue');
            
            // Determine if a playlist is active based on the presence of playlistSongsQueue
            isPlaylistActive = !!playlistSongsQueueJSON;

            // If a specific song ID is present, it means we navigated from library.html or playlist.html
            // If it's from playlist.html, isPlaylistActive will already be true.
            // If it's from library.html (single song), we explicitly set isPlaylistActive to false for this load.
            if (songToPlayFromPlaylistId && !isPlaylistActive) {
                console.log(`[DOMContentLoaded] Found songToPlayFromPlaylistId in localStorage: ${songToPlayFromPlaylistId}. Loading as individual song.`);
                isPlaylistActive = false; // Ensure playlist mode is OFF for individual song loads
                try {
                    console.log(`[DOMContentLoaded] Fetching song details for ID: ${songToPlayFromPlaylistId}`);
                    const response = await fetch(`/api/library/${songToPlayFromPlaylistId}`);
                    if (response.ok) {
                        const songDetails = await response.json();
                        console.log(`[DOMContentLoaded] Song details fetched: Name: ${songDetails.name}, File Path: ${songDetails.file_path}`); // Added file_path to log
                        if (songDetails && songDetails.file_path) {
                            const localPdfUrl = `/local_pdfs/${songDetails.file_path}`;
                            await loadPdf(localPdfUrl);
                        } else {
                            console.error(`[DOMContentLoaded] Fetched song details for ID ${songToPlayFromPlaylistId} missing 'file_path':`, songDetails);
                            showMessage(`Selected song details incomplete. Could not load PDF.`, 3000);
                            pdfDoc = null; // Ensure pdfDoc is null
                            pdfContextLeft.clearRect(0, 0, pdfCanvasLeft.width, pdfCanvasLeft.height);
                            pdfContextRight.clearRect(0, 0, pdfCanvasRight.width, pdfCanvasRight.height);
                            showLoading(false);
                        }
                    } else {
                        console.error(`[DOMContentLoaded] API call failed for song ID ${songToPlayFromPlaylistId}. Status: ${response.status}`);
                        showMessage(`Could not load song ID ${songToPlayFromPlaylistId}.`, 3000);
                        pdfDoc = null; // Ensure pdfDoc is null
                        pdfContextLeft.clearRect(0, 0, pdfCanvasLeft.width, pdfCanvasLeft.height);
                        pdfContextRight.clearRect(0, 0, pdfCanvasRight.width, pdfCanvasRight.height);
                        showLoading(false);
                    }
                } catch (error) {
                    console.error("[DOMContentLoaded] Error during API call for song ID:", songToPlayFromPlaylistId, error);
                    showMessage("Error loading selected song.", 3000);
                    pdfDoc = null; // Ensure pdfDoc is null
                    pdfContextLeft.clearRect(0, 0, pdfCanvasLeft.width, pdfCanvasLeft.height);
                    pdfContextRight.clearRect(0, 0, pdfCanvasRight.width, pdfCanvasRight.height);
                    showLoading(false);
                } finally {
                    localStorage.removeItem('songToPlayFromPlaylistId'); // Clean up the localStorage flag
                    console.log("[DOMContentLoaded] Cleaned up 'songToPlayFromPlaylistId' from localStorage.");
                }
            } else if (isPlaylistActive) {
                // If a playlist is active (from previous session or navigation), initialize setlist
                console.log("[DOMContentLoaded] Playlist active. Initializing setlist.");
                await initializeSetlist();
            } else {
                // No specific song or active playlist
                console.log("[DOMContentLoaded] No specific song or active playlist. Displaying initial message.");
                showMessage("No PDF loaded. Please select a song from the Library or play a playlist.", 5000);
                pdfDoc = null;
                pdfContextLeft.clearRect(0, 0, pdfCanvasLeft.width, pdfCanvasLeft.height);
                pdfContextRight.clearRect(0, 0, pdfCanvasRight.width, pdfCanvasRight.height);
                showLoading(false);
            }

            console.log("[DOMContentLoaded] App startup routine complete.");
        });
    </script>
</body>
</html>
