<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sheet Pro</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- PDF.js library for rendering PDFs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <style>
        /* Apply the Inter font globally */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
        }
        /* Hide scrollbars for a cleaner app-like look */
        body::-webkit-scrollbar {
            display: none;
        }
        body {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        /* Styling for disabled buttons to indicate their state */
        .button-disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none; /* Disable pointer events on disabled buttons */
        }
        /* Container for the PDF pages */
        .pdf-page-container {
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Hide overflow from scaling */
            position: relative; /* For overlay click areas */
        }
        /* Canvas element styling */
        .pdf-page-canvas {
            width: 100%;
            height: 100%;
            display: block;
            background-color: #fff; /* White background for the canvas */
        }
        /* Clickable overlays for page navigation */
        .page-nav-overlay {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 50%; /* Each overlay takes 50% of its relative parent (pdfViewerContainer) */
            z-index: 5; /* Above canvases, below loading overlay */
            cursor: pointer;
        }
        .page-nav-overlay.left {
            left: 0;
        }
        .page-nav-overlay.right {
            right: 0;
        }
        /* Style for a custom message box */
        #messageBox {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            pointer-events: none;
        }
        #messageBox.active {
            opacity: 1;
        }

        /* Style for when an item is being dragged to show a 'grabbing' hand cursor */
        body.dragging-active, body.dragging-active * {
            cursor: grabbing !important;
        }

        /* When dragging, disable pointer events on the children of any potential drop target.
           This ensures the dragover event fires on the LI itself, not its children. */
        body.dragging-active li:not(.opacity-50) * {
            pointer-events: none;
        }

        /* --- Focus Mode Styles --- */
        body.focus-mode header,
        body.focus-mode #playlistContainer,
        body.focus-mode #pageInfoContainer {
            display: none !important;
        }

        body.focus-mode #appLayout {
            padding: 0;
            gap: 0;
        }

        body.focus-mode #pdfMainContent > div {
            border-radius: 0;
            padding: 0;
        }

        #exitFocusModeButton {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 110; /* Higher than other UI elements */
            background-color: rgba(31, 41, 55, 0.75); /* bg-gray-800 with opacity */
            color: white;
            width: 3rem;
            height: 3rem;
            border-radius: 9999px; /* rounded-full */
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
            font-size: 1.25rem; /* Larger icon */
        }
        body.focus-mode #exitFocusModeButton {
            display: flex;
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col bg-gray-100 text-gray-800 overflow-hidden">

    <!-- Header Section - Mimicking ForScore's top bar -->
    <header class="flex items-center justify-between p-4 bg-gray-900 text-white shadow-lg z-10">
        <!-- Left group of buttons -->
        <div class="flex items-center space-x-4">
            <!-- Library button restored -->
            <button id="libraryButton" class="flex items-center px-4 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition-colors text-sm font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                <i class="fas fa-book mr-2"></i> Library
            </button>
            <button id="playlistsButton" class="flex items-center px-4 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition-colors text-sm font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                <i class="fas fa-list-alt mr-2"></i> Playlist
            </button>
        </div>

        <!-- App Title in the center -->
        <h1 class="text-2xl font-bold text-indigo-400">Sheet Pro</h1>

        <!-- Right group of buttons -->
        <div class="flex items-center space-x-4">
            <!-- <button id="searchButton" class="flex items-center px-4 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition-colors text-sm font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                <i class="fas fa-search mr-2"></i> Search
            </button>
            <button id="annotateButton" class="flex items-center px-4 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition-colors text-sm font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                <i class="fas fa-pencil-alt mr-2"></i> Annotate
            </button>
            <button id="toolsButton" class="flex items-center px-4 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition-colors text-sm font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                <i class="fas fa-wrench mr-2"></i> Tools
            </button> -->
            <button id="focusModeToggle" class="flex items-center px-4 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition-colors text-sm font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                <i class="fas fa-expand mr-2"></i> Focus
            </button>
            <button id="fullscreenToggle" class="flex items-center px-4 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-700 transition-colors text-sm font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                <i class="fas fa-expand-arrows-alt mr-2"></i> Fullscreen
            </button>
        </div>
    </header>

    <!-- Main content area that will handle layout changes based on orientation -->
    <div id="appLayout" class="flex-1 flex flex-col lg:flex-row p-4 gap-4">
        <!-- Playlist Container - Controlled purely by JS now -->
        <div id="playlistContainer" class="w-full lg:w-64 bg-white rounded-xl shadow-lg p-4 overflow-y-auto flex-shrink-0 z-10 transition-all duration-300 ease-in-out hidden">
            <!-- Buttons go here -->
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-gray-700" id="playlistTitle">Playlist</h2>
                <div>
                    <button id="closePlaylistButton" class="text-gray-500 hover:text-gray-700 p-1 rounded-full hover:bg-gray-200">
                        <i class="fas fa-times"></i>
                    </button>
                    <button id="movePlaylistButton" class="text-gray-500 hover:text-gray-700 p-1 rounded-full hover:bg-gray-200 ml-2">
                        <i class="fas fa-exchange-alt"></i>
                    </button>
                </div>
            </div>
            <ul id="playlistItems" class="space-y-2">
                <!-- Playlist items will be dynamically inserted here -->
            </ul>
        </div>

        <!-- Page Info Container - Displays page numbers when playlist is not active -->
        <!-- This container will now always be hidden if not in playlist mode, as per user request -->
        <div id="pageInfoContainer" class="w-full lg:w-64 bg-white rounded-xl shadow-lg p-4 flex-shrink-0 z-10 transition-all duration-300 ease-in-out hidden flex-col items-center justify-center text-gray-700 text-2xl font-bold">
            <span id="currentPageOfTotal"></span>
        </div>

        <!-- Main PDF Viewer Area -->
        <main id="pdfMainContent" class="flex-1 flex flex-col items-center justify-center relative z-20">
            <div class="bg-white rounded-xl shadow-lg w-full h-full overflow-hidden flex flex-col p-4">
                <!-- PDF Viewer Canvases and Loading Overlay -->
                <!-- Justify to start or end will be controlled by JS. No middle page anymore. -->
                <div id="pdfViewerContainer" class="flex-1 flex items-stretch relative gap-x-0 flex-nowrap justify-center">
                    <!-- Left Page Container (always visible if any page is rendered) -->
                    <div id="pdfPageLeftContainer" class="pdf-page-container flex-shrink-0">
                        <canvas id="pdfCanvasLeft" class="pdf-page-canvas"></canvas>
                    </div>
                    <!-- Right Page Container (shown for 2-page view) -->
                    <div id="pdfPageRightContainer" class="pdf-page-container flex-shrink-0 hidden">
                        <canvas id="pdfCanvasRight" class="pdf-page-canvas"></canvas>
                    </div>

                    <!-- Navigation Overlays (moved outside of pdfPageContainers to always be active) -->
                    <div id="leftNavOverlay" class="page-nav-overlay left"></div>
                    <div id="rightNavOverlay" class="page-nav-overlay right"></div>

                    <!-- Loading Overlay -->
                    <div id="loadingOverlay" class="absolute inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center text-white text-xl rounded-xl transition-opacity duration-300 opacity-0 pointer-events-none">
                        <i class="fas fa-spinner fa-spin mr-2"></i> Loading PDF...
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Message box for user feedback -->
    <div id="messageBox" class="fixed bottom-8 left-4 right-4 bg-gray-800 text-white px-6 py-3 rounded-lg shadow-lg opacity-0 transition-opacity duration-300 pointer-events-none z-50">
    </div>

    <!-- Collapsible Aside for Library - Restored -->
    <aside id="libraryAside" class="fixed top-0 left-0 h-screen w-64 bg-gray-800 text-white shadow-xl z-20 transform -translate-x-full transition-transform duration-300 ease-in-out flex flex-col">
        <div class="p-4 flex items-center justify-between border-b border-gray-700">
            <h2 class="text-xl font-bold">Library</h2>
            <button id="closeAsideButton" class="text-gray-400 hover:text-white transition-colors">
                <i class="fas fa-times text-2xl"></i>
            </button>
        </div>
        <div class="flex-1 overflow-y-auto p-4">
            <h3 class="text-lg font-semibold mb-2 text-indigo-300">Artists</h3>
            <ul class="mb-4 space-y-1">
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Ludwig van Beethoven</a></li>
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Wolfgang Amadeus Mozart</a></li>
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Johann Sebastian Bach</a></li>
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Frédéric Chopin</a></li>
            </ul>

            <h3 class="text-lg font-semibold mb-2 text-indigo-300">Genres</h3>
            <ul class="mb-4 space-y-1">
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Classical</a></li>
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Romantic</a></li>
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Baroque</a></li>
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Jazz</a></li>
            </ul>

            <h3 class="text-lg font-semibold mb-2 text-indigo-300">Collections</h3>
            <ul class="space-y-1">
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">My Favorites</a></li>
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Practice Pieces</a></li>
                <li><a href="#" class="block py-1 hover:bg-gray-700 rounded-md px-2">Performance Repertoire</a></li>
            </ul>
        </div>
    </aside>

    <!-- Exit Focus Mode Button -->
    <button id="exitFocusModeButton">
        <i class="fas fa-compress"></i>
    </button>

    <script>
        // Set up the PDF.js worker source
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        // Select elements from the DOM
        const body = document.body;
        const messageBox = document.getElementById('messageBox');
        const fullscreenToggle = document.getElementById('fullscreenToggle');
        const libraryButton = document.getElementById('libraryButton');
        const focusModeToggle = document.getElementById('focusModeToggle');
        const exitFocusModeButton = document.getElementById('exitFocusModeButton');
        const playlistsButton = document.getElementById('playlistsButton');
        const libraryAside = document.getElementById('libraryAside');
        const closeAsideButton = document.getElementById('closeAsideButton');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const pdfViewerContainer = document.getElementById('pdfViewerContainer');
        const playlistContainer = document.getElementById('playlistContainer');
        const closePlaylistButton = document.getElementById('closePlaylistButton');
        const movePlaylistButton = document.getElementById('movePlaylistButton');
        const appLayout = document.getElementById('appLayout');
        const playlistTitleElement = document.getElementById('playlistTitle'); // Still used for the main title
        const playlistItemsUl = document.getElementById('playlistItems');

        // New elements for page number display
        const pageInfoContainer = document.getElementById('pageInfoContainer');
        const currentPageOfTotalSpan = document.getElementById('currentPageOfTotal');


        const pdfCanvasLeft = document.getElementById('pdfCanvasLeft');
        const pdfContextLeft = pdfCanvasLeft.getContext('2d');
        const pdfCanvasRight = document.getElementById('pdfCanvasRight');
        const pdfContextRight = pdfCanvasRight.getContext('2d');

        const pdfPageLeftContainer = document.getElementById('pdfPageLeftContainer');
        const pdfPageRightContainer = document.getElementById('pdfPageRightContainer');

        const leftNavOverlay = document.getElementById('leftNavOverlay');
        const rightNavOverlay = document.getElementById('rightNavOverlay');

        // Get all buttons that are NOT inside the libraryAside for disabling
        const allButtons = Array.from(document.querySelectorAll('button'));
        const nonAsideButtons = allButtons.filter(button => !libraryAside.contains(button));


        let pdfDoc = null;
        let currentPageNum = 1;
        let isPlaylistReversed = false;
        let previousOrientationIsPortrait = window.innerHeight > window.innerWidth;
        let isPlaylistOpen; // Initialized in initializePlaylist
        let currentViewablePlaylistSongs = []; // Array of song objects for the current playlist
        let currentSongIndexInPlaylist = -1; // Index of the currently displayed song in currentViewablePlaylistSongs
        let currentPlayingPlaylistName = ''; // Name of the currently playing playlist
        let currentPlaylistId = null; // ID of the currently active playlist
        let isPlaylistActive = false; // New flag to indicate if a playlist is being played

        let renderTaskLeft = null;
        let renderTaskRight = null;
        let currentPdfUrl = null; // Track the currently loaded PDF URL
        let wasFullscreenBeforeFocus = false; // Track fullscreen state before entering focus mode

        let draggedItem = null; // Stores the currently dragged list item


        /**
         * Displays a temporary message box to the user.
         * @param {string} message - The message to display.
         * @param {number} duration - How long the message should be visible in milliseconds.
         */
        function showMessage(message, duration = 3000) {
            messageBox.textContent = message;
            messageBox.classList.remove('opacity-0');
            messageBox.classList.add('opacity-100');
            setTimeout(() => {
                messageBox.classList.remove('opacity-100');
                messageBox.classList.add('opacity-0');
            }, duration);
        }

        /**
         * Removes the file extension from a given filename string.
         * @param {string} filename - The filename with or without an extension.
         * @returns {string} The filename without its extension.
         */
        function removeFileExtension(filename) {
            const lastDotIndex = filename.lastIndexOf('.');
            if (lastDotIndex === -1) {
                return filename; // No extension found
            }
            if (lastDotIndex === 0 || lastDotIndex === filename.length - 1) {
                return filename;
            }
            return filename.substring(0, lastDotIndex);
        }

        /**
         * Shows or hides the loading overlay.
         * @param {boolean} isLoading - True to show, false to hide.
         */
        function showLoading(isLoading) {
            if (isLoading) {
                loadingOverlay.classList.remove('opacity-0', 'pointer-events-none');
                loadingOverlay.classList.add('opacity-100');
            } else {
                loadingOverlay.classList.remove('opacity-100');
                loadingOverlay.classList.add('opacity-0', 'pointer-events-none');
            }
        }

        /**
         * Renders a specific PDF page onto a given canvas.
         * @param {object} pdfPage - The PDF page object from PDF.js.
         * @param {HTMLCanvasElement} canvas - The canvas element to render on.
         * @param {CanvasRenderingContext2D} context - The 2D rendering context of the canvas.
         * @param {string} canvasId - 'left' or 'right' to track the render task.
         * @param {number} totalPagesDisplayed - The total number of pages currently being displayed (1 or 2).
         */
        async function renderPage(pdfPage, canvas, context, canvasId, totalPagesDisplayed) {
            // Cancel any existing render task for this canvas
            if (canvasId === 'left' && renderTaskLeft) {
                renderTaskLeft.cancel();
                renderTaskLeft = null;
            } else if (canvasId === 'right' && renderTaskRight) {
                renderTaskRight.cancel();
                renderTaskRight = null;
            }

            // Get viewport for the page at a base scale
            const viewport = pdfPage.getViewport({ scale: 1 });

            // Get current dimensions of the pdfViewerContainer (parent of pdfPageContainers)
            const availableViewerWidth = pdfViewerContainer.clientWidth;
            const availableViewerHeight = pdfViewerContainer.clientHeight;

            // Calculate maximum available width and height for a single page based on totalPagesDisplayed
            const maxPageWidth = availableViewerWidth / totalPagesDisplayed;
            const maxPageHeight = availableViewerHeight;

            // Calculate scale to fit the page into its calculated slot, maintaining aspect ratio
            const scaleX = maxPageWidth / viewport.width;
            const scaleY = maxPageHeight / viewport.height;
            const renderScale = Math.min(scaleX, scaleY);

            const scaledViewport = pdfPage.getViewport({ scale: renderScale });

            const resolutionScale = window.devicePixelRatio || 1;

            canvas.width = scaledViewport.width * resolutionScale;
            canvas.height = scaledViewport.height * resolutionScale;

            // Set the *CSS* dimensions of the canvas element.
            canvas.style.width = scaledViewport.width + 'px';
            canvas.style.height = scaledViewport.height + 'px';

            // Set the dimensions of the parent container to match the canvas dimensions
            // This is crucial to make the container snug around the rendered PDF content
            canvas.parentElement.style.width = scaledViewport.width + 'px';
            canvas.parentElement.style.height = scaledViewport.height + 'px';

            context.scale(resolutionScale, resolutionScale);

            const renderContext = {
                canvasContext: context,
                viewport: scaledViewport,
            };

            // Store the render task
            const renderTask = pdfPage.render(renderContext);
            if (canvasId === 'left') {
                renderTaskLeft = renderTask;
            } else if (canvasId === 'right') {
                renderTaskRight = renderTask;
            }

            try {
                await renderTask.promise;
            } catch (error) {
                // Ignore render cancellation errors
                if (error.name === 'RenderingCancelledException') {
                    console.log(`Render for ${canvasId} cancelled.`);
                } else {
                    console.error(`Error rendering ${canvasId} page:`, error);
                    throw error; // Re-throw other errors
                }
            } finally {
                // Clear the task reference after completion or cancellation
                if (canvasId === 'left') {
                    renderTaskLeft = null;
                } else if (canvasId === 'right') {
                    renderTaskRight = null;
                }
                context.setTransform(1, 0, 0, 1, 0, 0); // Reset context transform
            }
        }

        /**
         * Renders PDF pages based on current page number and screen orientation.
         */
        async function renderPdfPages() {
            if (!pdfDoc) {
                // If no PDF is loaded, ensure both containers are hidden and page info is cleared
                playlistContainer.classList.add('hidden');
                pageInfoContainer.classList.add('hidden');
                currentPageOfTotalSpan.textContent = '';
                return;
            }

            showLoading(true);

            // Clear canvases before rendering new pages
            pdfContextLeft.clearRect(0, 0, pdfCanvasLeft.width, pdfCanvasLeft.height);
            pdfContextRight.clearRect(0, 0, pdfCanvasRight.width, pdfCanvasRight.height);

            const currentIsPortrait = window.innerHeight > window.innerWidth;

            let numPagesToDisplay = 1; // Default to 1 page mode
            if (!currentIsPortrait && pdfDoc.numPages >= 2) {
                numPagesToDisplay = 2; // 2-page mode in landscape if at least 2 pages exist
            }

            // Adjust currentPageNum based on orientation change and number of pages to display
            let targetFirstVisiblePage = currentPageNum;
            if (previousOrientationIsPortrait && !currentIsPortrait) { // Portrait to Landscape
                if (numPagesToDisplay === 2) {
                    // If moving to 2-page mode and current page is even, shift to previous odd page
                    if (currentPageNum % 2 === 0 && currentPageNum > 1) {
                        targetFirstVisiblePage = currentPageNum - 1;
                    }
                }
            }
            // Ensure currentPageNum doesn't go below 1 or beyond what's available
            // In landscape, we want to be able to show the last page, even if it's by itself.
            // The check should only prevent starting on a page that doesn't exist.
            if (numPagesToDisplay === 2) {
                currentPageNum = Math.max(1, Math.min(targetFirstVisiblePage, pdfDoc.numPages));
            } else { // For portrait, the old logic is fine.
                currentPageNum = Math.max(1, Math.min(targetFirstVisiblePage, pdfDoc.numPages - numPagesToDisplay + 1));
            }
            previousOrientationIsPortrait = currentIsPortrait;

            // Handle playlist and pageInfoContainer visibility based on orientation and isPlaylistActive state
            if (!currentIsPortrait && isPlaylistActive && isPlaylistOpen) { // Landscape, playlist active, and user wants it open
                playlistContainer.classList.remove('hidden');
                pageInfoContainer.classList.add('hidden'); // Hide page info when playlist is shown
            } else { // Portrait OR not in playlist mode OR user closed it
                playlistContainer.classList.add('hidden');
                pageInfoContainer.classList.add('hidden'); // Always hide both if not in playlist mode or if in portrait
            }


            // Adjust justify-content to center for all page display modes
            pdfViewerContainer.classList.add('justify-center');
            pdfViewerContainer.classList.remove('justify-start', 'justify-end');

            // Hide all potential pages first, then show what's needed
            pdfPageLeftContainer.style.display = 'none';
            pdfPageRightContainer.style.display = 'none';

            try {
                // Always render the first page in the current view
                if (pdfDoc.numPages >= currentPageNum) {
                    pdfPageLeftContainer.style.display = 'flex';
                    await renderPage(await pdfDoc.getPage(currentPageNum), pdfCanvasLeft, pdfContextLeft, 'left', numPagesToDisplay);
                }

                // Render second page (if 2-page mode)
                if (numPagesToDisplay === 2 && pdfDoc.numPages >= currentPageNum + 1) {
                    pdfPageRightContainer.style.display = 'flex';
                    await renderPage(await pdfDoc.getPage(currentPageNum + 1), pdfCanvasRight, pdfContextRight, 'right', numPagesToDisplay);
                }

            } catch (error) {
                console.error('Error rendering PDF pages:', error);
                showMessage('Error rendering PDF pages. Please try again.', 5000);
            } finally {
                showLoading(false);
            }
        }

        /**
         * Loads a PDF document from a given URL.
         * @param {string} url - The URL of the PDF document.
         */
        async function loadPdf(url) {
            showLoading(true);
            try {
                if (renderTaskLeft) { renderTaskLeft.cancel(); renderTaskLeft = null; }
                if (renderTaskRight) { renderTaskRight.cancel(); renderTaskRight = null; }

                pdfDoc = await pdfjsLib.getDocument(url).promise;
                currentPageNum = 1;
                currentPdfUrl = url; // Store the URL of the successfully loaded PDF
                
                await renderPdfPages();
                showMessage('PDF loaded successfully!');
            } catch (error) {
                console.error('Error loading PDF:', error);
                // Display specific error message instead of falling back to default PDF
                showMessage('Error: Could not load PDF. Please ensure the file exists on the server or the path is correct.', 5000);
                pdfDoc = null; // Ensure pdfDoc is null if loading failed
            } finally {
                showLoading(false);
            }
        }

        /**
         * Checks if the document is currently in fullscreen mode.
         * @returns {boolean} True if in fullscreen, false otherwise.
         */
        function isFullscreen() {
            return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
        }

        /**
         * Enters fullscreen mode.
         */
        function enterFullscreen() {
            if (libraryAside.classList.contains('translate-x-0')) {
                showMessage("Please close the Library panel before entering fullscreen mode.", 3000);
                return;
            }
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(err => showMessage(`Error entering fullscreen: ${err.message}`, 5000));
            } else if (document.documentElement.webkitRequestFullscreen) {
                document.documentElement.webkitRequestFullscreen().catch(err => showMessage(`Error entering fullscreen: ${err.message}`, 5000));
            } else if (document.documentElement.msRequestFullscreen) {
                document.documentElement.msRequestFullscreen().catch(err => showMessage(`Error entering fullscreen: ${err.message}`, 5000));
            } else {
                showMessage("Fullscreen mode is not supported by your browser.", 5000);
            }
        }

        /**
         * Exits fullscreen mode.
         */
        function exitFullscreen() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }

        /**
         * Toggles fullscreen mode for the document.
         */
        function toggleFullscreen() {
            if (!isFullscreen()) {
                enterFullscreen();
            } else {
                exitFullscreen();
            }
        }

        // Add event listener to the fullscreen toggle button
        fullscreenToggle.addEventListener('click', toggleFullscreen);

        /**
         * Toggles focus mode, hiding UI elements to focus on the PDF.
         */
        function toggleFocusMode() {
            const isEnteringFocusMode = !body.classList.contains('focus-mode');
            let fullscreenActionTaken = false;

            if (isEnteringFocusMode) {
                // Entering focus mode
                wasFullscreenBeforeFocus = isFullscreen();
                if (!wasFullscreenBeforeFocus) {
                    enterFullscreen();
                    fullscreenActionTaken = true;
                }
                body.classList.add('focus-mode');
            } else {
                // Exiting focus mode
                body.classList.remove('focus-mode');
                if (!wasFullscreenBeforeFocus && isFullscreen()) {
                    exitFullscreen();
                    fullscreenActionTaken = true;
                }
            }

            // If no fullscreen action was taken, we must manually trigger a re-render.
            // The 'fullscreenchange' event handler will do it otherwise.
            if (!fullscreenActionTaken) {
                setTimeout(() => { if (pdfDoc) renderPdfPages(); }, 150);
            }
        }
        // Add event listeners for both entering and exiting focus mode
        focusModeToggle.addEventListener('click', toggleFocusMode);
        exitFocusModeButton.addEventListener('click', toggleFocusMode);

        /**
         * Handles changes in fullscreen state by re-rendering the PDF.
         * A delay is necessary to allow the browser to reflow the layout.
         */
        function handleFullscreenChange() {
            // A small delay is needed to allow the browser to finish its layout reflow.
            // 50ms can be too short, leading to incorrect size calculations.
            setTimeout(() => {
                if (pdfDoc) {
                    renderPdfPages();
                }
            }, 150);
        }

        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('msfullscreenchange', handleFullscreenChange);

        /**
         * Disables/enables buttons that are not part of the library aside.
         * @param {boolean} disabled - True to disable, false to enable.
         */
        function setNonAsideButtonsState(disabled) {
            nonAsideButtons.forEach(button => {
                button.disabled = disabled;
                if (disabled) {
                    button.classList.add('button-disabled');
                } else {
                    button.classList.remove('button-disabled');
                }
            });
            if (disabled) {
                // Ensure other interactive areas are disabled too, e.g., the PDF navigation overlays
                pdfViewerContainer.classList.add('pointer-events-none');
            } else {
                pdfViewerContainer.classList.remove('pointer-events-none');
            }
        }

        /**
         * Toggles the visibility of the library aside (the sliding panel).
         * @param {boolean} [show] - Optional. True to show, false to hide. If omitted, it toggles the current state.
         */
        function toggleAside(show) {
            if (show === true) {
                libraryAside.classList.remove('-translate-x-full');
                libraryAside.classList.add('translate-x-0');
                setNonAsideButtonsState(true); // Disable buttons when aside opens
            } else if (show === false) {
                libraryAside.classList.remove('translate-x-0');
                libraryAside.classList.add('-translate-x-full');
                setNonAsideButtonsState(false); // Enable buttons when aside closes
            } else { // Toggle if 'show' is undefined
                const isAsideOpen = libraryAside.classList.contains('translate-x-0');
                if (isAsideOpen) {
                    toggleAside(false);
                } else {
                    toggleAside(true);
                }
            }
        }

        // Add event listener to the "Library" button to open the library aside
        libraryButton.addEventListener('click', () => {
            // Redirect to library.html
            window.location.href = 'library.html';
        });

        // Add event listener to the close button inside the library aside
        closeAsideButton.addEventListener('click', () => toggleAside(false));

        // Event listener for clicks anywhere on the document to close the library aside if open and click is outside
        document.addEventListener('click', (event) => {
            const isClickInsideAside = libraryAside.contains(event.target);
            const isLibraryButton = event.target === libraryButton || libraryButton.contains(event.target);

            if (libraryAside.classList.contains('translate-x-0') && !isClickInsideAside && !isLibraryButton) {
                toggleAside(false);
            }
        });

        playlistsButton.addEventListener('click', () => {
            isPlaylistOpen = !isPlaylistOpen;
            if (pdfDoc) {
                renderPdfPages(); // Re-render to show/hide playlist based on new state
            }
        });

        closePlaylistButton.addEventListener('click', () => {
            console.log("hiding panel");
            playlistContainer.classList.add('hidden');
            isPlaylistOpen = false;
            if (pdfDoc) {
                renderPdfPages();
            }
        });

        movePlaylistButton.addEventListener('click', () => {
            const currentIsPortrait = window.innerHeight > window.innerWidth;

            if (currentIsPortrait) {
                appLayout.classList.toggle('flex-col-reverse');
            } else {
                appLayout.classList.toggle('lg:flex-row-reverse');
            }
            isPlaylistReversed = !isPlaylistReversed;
        });

        leftNavOverlay.addEventListener('click', async () => {
            if (!pdfDoc) {
                showMessage("No PDF loaded.", 2000);
                return;
            }
            console.log(`[LeftNav] Clicked. Current state:
                isPlaylistActive: ${isPlaylistActive}
                currentSongIndexInPlaylist: ${currentSongIndexInPlaylist}
                currentViewablePlaylistSongs.length: ${currentViewablePlaylistSongs.length}
                currentPageNum: ${currentPageNum}
                pdfDoc.numPages: ${pdfDoc.numPages}`);

            const currentIsPortrait = window.innerHeight > window.innerWidth;
            let currentPagesToDisplay = 1;
            if (!currentIsPortrait && pdfDoc.numPages >= 2) {
                currentPagesToDisplay = 2;
            }

            // In two-page view, we always want to turn by two pages.
            const step = currentPagesToDisplay;

            // If not on the first page of the current PDF, just go back pages
            if (currentPageNum > 1) {
                currentPageNum = Math.max(1, currentPageNum - step); // Go back by 2 pages in landscape
                console.log(`[LeftNav] Going back page. New currentPageNum: ${currentPageNum}`);
                await renderPdfPages(); // Await the rendering
            } else if (isPlaylistActive && currentSongIndexInPlaylist > 0) {
                // If on the first page AND a playlist is active AND there's a previous song
                currentSongIndexInPlaylist--;
                const prevSong = currentViewablePlaylistSongs[currentSongIndexInPlaylist];
                if (prevSong && prevSong.file_path) {
                    showMessage(`Playing previous song: ${prevSong.name}`, 2000);
                    // No need to update last played date for previous song
                    await loadPdf(`/local_pdfs/${prevSong.file_path}`);
                    renderPlaylist(); // Re-render playlist to highlight current song
                } else {
                    showMessage(`Could not load previous song "${prevSong.name}". File path missing.`, 3000);
                    console.error("Previous song in playlist missing file_path or invalid:", prevSong);
                }
            } else {
                showMessage("You are on the first page(s) or at the beginning of the playlist.", 2000);
            }
        });

        rightNavOverlay.addEventListener('click', async () => {
            if (!pdfDoc) {
                showMessage("No PDF loaded.", 2000);
                return;
            }
            console.log(`[RightNav] Clicked. Current state:
                isPlaylistActive: ${isPlaylistActive}
                currentSongIndexInPlaylist: ${currentSongIndexInPlaylist}
                currentViewablePlaylistSongs.length: ${currentViewablePlaylistSongs.length}
                currentPageNum: ${currentPageNum}
                pdfDoc.numPages: ${pdfDoc.numPages}`);

            const currentIsPortrait = window.innerHeight > window.innerWidth;
            let currentPagesToDisplay = 1;
            if (!currentIsPortrait && pdfDoc.numPages >= 2) {
                currentPagesToDisplay = 2;
            }

            // In two-page view, we always want to turn by two pages.
            const step = currentPagesToDisplay;

            // If advancing pages within the current PDF
            // Check if there are more pages to show
            // The new current page number must be less than or equal to the total number of pages.
            if (currentPageNum + step <= pdfDoc.numPages) {
                currentPageNum += step; // Always advance by the step (1 for portrait, 2 for landscape)
                console.log(`[RightNav] Advancing page. New currentPageNum: ${currentPageNum}`);
                await renderPdfPages(); // Await the rendering
            } else if (isPlaylistActive && currentSongIndexInPlaylist !== -1 && currentSongIndexInPlaylist < currentViewablePlaylistSongs.length - 1) {
                // If on the last page of current PDF AND a playlist is active AND there's a next song
                currentSongIndexInPlaylist++;
                const nextSong = currentViewablePlaylistSongs[currentSongIndexInPlaylist];
                if (nextSong && nextSong.file_path) {
                    showMessage(`Playing next song: ${nextSong.name}`, 2000);
                    // Update the last played date for the *new* song
                    fetch(`/api/library/${nextSong.id}/play`, { method: 'POST' })
                        .then(res => res.json())
                        .then(data => console.log(data.message || data.error))
                        .catch(error => console.error("Error updating play date for next song:", error));

                    await loadPdf(`/local_pdfs/${nextSong.file_path}`);
                    renderPlaylist(); // Re-render playlist to highlight current song
                } else {
                    showMessage(`Could not load next song "${nextSong.name}". File path missing.`, 3000);
                    console.error("Next song in playlist missing file_path or invalid:", nextSong);
                }
            } else {
                showMessage("You are on the last page(s) or at the end of the playlist.", 2000);
            }
        });

        // Event listener for window resize to re-render PDF pages and adjust layout
        window.addEventListener('resize', () => {
            if (pdfDoc) {
                renderPdfPages();
            }
            const currentIsPortrait = window.innerHeight > window.innerWidth;
            if (isPlaylistReversed) {
                if (currentIsPortrait) {
                    appLayout.classList.add('flex-col-reverse');
                    appLayout.classList.remove('lg:flex-row-reverse');
                } else {
                    appLayout.classList.remove('flex-col-reverse');
                    appLayout.classList.add('lg:flex-row-reverse');
                }
            } else {
                appLayout.classList.remove('flex-col-reverse');
                appLayout.classList.remove('lg:flex-row-reverse');
            }
        });

        /**
         * Initializes the playlist panel by fetching song details from localStorage
         * and populating the playlist UI.
         */
        async function initializePlaylist() {
            console.log("[Playlist Init] Initializing playlist.");
            const playlistSongsQueueJSON = localStorage.getItem('playlistSongsQueue');
            currentPlayingPlaylistName = localStorage.getItem('currentPlayingPlaylistName') || 'Current Playlist';
            
            // Determine if a playlist is active based on the presence of playlistSongsQueue
            isPlaylistActive = !!playlistSongsQueueJSON;

            const storedPlaylistOpen = localStorage.getItem('isPlaylistOpen');
            // isPlaylistOpen should only be true if a playlist is active AND it was previously open
            isPlaylistOpen = (storedPlaylistOpen === 'true' && isPlaylistActive); 

            const storedPlaylistReversed = localStorage.getItem('isPlaylistReversed');
            isPlaylistReversed = (storedPlaylistReversed === 'true');

            const currentIsPortrait = window.innerHeight > window.innerWidth;
            if (isPlaylistReversed) {
                if (currentIsPortrait) {
                    appLayout.classList.add('flex-col-reverse');
                } else {
                    appLayout.classList.add('lg:flex-row-reverse');
                }
            }

            if (isPlaylistActive) {
                console.log("[Playlist Init] playlistSongsQueue found in localStorage. Setting isPlaylistActive to true.");
                
                // Show playlist if in landscape and it was previously open
                if (isPlaylistOpen && !currentIsPortrait) {
                    playlistContainer.classList.remove('hidden');
                    pageInfoContainer.classList.add('hidden'); // Hide page info when playlist is shown
                } else { // Hide playlist if portrait or not open
                    playlistContainer.classList.add('hidden');
                    pageInfoContainer.classList.add('hidden'); // Also hide page info container
                }
                
                const songIds = JSON.parse(playlistSongsQueueJSON);
                const fetchedSongs = [];

                for (const songId of songIds) {
                    console.log(`[Playlist Init] Fetching details for song ID: ${songId}`);
                    try {
                        const response = await fetch(`/api/library/${songId}`);
                        if (response.ok) {
                            const songDetails = await response.json();
                            fetchedSongs.push(songDetails);
                            console.log(`[Playlist Init] Fetched song details for ID ${songId}: Name: ${songDetails.name}, File Path: ${songDetails.file_path}`); // Added file_path to log
                        } else {
                            console.warn(`[Playlist Init] Failed to fetch details for song ID ${songId}. Status: ${response.status}`);
                            fetchedSongs.push({ id: songId, name: `Unknown Song ${songId}`, title: `Unknown Song ${songId}`, file_path: null }); // Ensure file_path is explicitly null
                        }
                    } catch (error) {
                        console.error(`[Playlist Init] Error fetching song details for ID ${songId}:`, error);
                        fetchedSongs.push({ id: songId, name: `Error Loading Song ${songId}`, title: `Error Loading Song ${songId}`, file_path: null }); // Ensure file_path is explicitly null
                    }
                }
                currentViewablePlaylistSongs = fetchedSongs;
                renderPlaylist();

                // Determine the initial song to load if a playlist is active
                const songToPlayFromPlaylistId = localStorage.getItem('songToPlayFromPlaylistId');
                if (songToPlayFromPlaylistId) {
                    // Find the index of the specific song requested
                    currentSongIndexInPlaylist = currentViewablePlaylistSongs.findIndex(song => song.id == songToPlayFromPlaylistId);
                    localStorage.removeItem('songToPlayFromPlaylistId'); // Clear the flag
                } else {
                    // If no specific song was requested, default to the first song in the playlist
                    currentSongIndexInPlaylist = 0;
                }

                // Load the determined initial song from the playlist
                console.log(`[Playlist Init DEBUG] Before initial song load check: currentSongIndexInPlaylist=${currentSongIndexInPlaylist}, currentViewablePlaylistSongs[currentSongIndexInPlaylist]=`, currentViewablePlaylistSongs[currentSongIndexInPlaylist]);
                if (currentSongIndexInPlaylist !== -1 && currentViewablePlaylistSongs[currentSongIndexInPlaylist]) { // Removed .file_path check here, as loadPdf handles it
                    const initialSong = currentViewablePlaylistSongs[currentSongIndexInPlaylist];
                    console.log(`[Playlist Init] Attempting to load initial song: ${initialSong.name}, file_path: ${initialSong.file_path}`); // Added log
                    if (initialSong.file_path) { // Perform file_path check before loading
                        await loadPdf(`/local_pdfs/${initialSong.file_path}`);
                        renderPlaylist(); // Re-render to highlight the initially loaded song
                    } else {
                        showMessage(`Could not load the first song in the playlist ("${initialSong.name}"). File path missing.`, 5000);
                        console.error("[Playlist Init] Initial playlist song missing file_path:", initialSong);
                        pdfDoc = null; // Ensure pdfDoc is null
                        pdfContextLeft.clearRect(0, 0, pdfCanvasLeft.width, pdfCanvasLeft.height);
                        pdfContextRight.clearRect(0, 0, pdfCanvasRight.width, pdfCanvasRight.height);
                        showLoading(false); // Ensure loading overlay is hidden
                    }
                } else {
                    showMessage("Could not load the first song in the playlist. Playlist is empty or song index is invalid.", 5000);
                    console.error("[Playlist Init] Initial playlist song missing or invalid index.");
                    // If the first song fails, do NOT load a default PDF. Keep it blank or show error.
                    pdfDoc = null; // Ensure pdfDoc is null
                    pdfContextLeft.clearRect(0, 0, pdfCanvasLeft.width, pdfCanvasLeft.height);
                    pdfContextRight.clearRect(0, 0, pdfCanvasRight.width, pdfCanvasRight.height);
                    showLoading(false); // Ensure loading overlay is hidden
                }

            } else {
                console.log("[Playlist Init] No playlistSongsQueue found. Hiding playlist and setting isPlaylistActive to false.");
                playlistContainer.classList.add('hidden');
                isPlaylistOpen = false;
                localStorage.setItem('isPlaylistOpen', isPlaylistOpen);
                // If no playlist is active, ensure currentSongIndexInPlaylist is reset
                currentSongIndexInPlaylist = -1; 
                // Always hide page info container if not in playlist mode
                pageInfoContainer.classList.add('hidden'); 
            }
            console.log("[Playlist Init] Playlist initialization complete. Final isPlaylistOpen:", isPlaylistOpen, "isPlaylistActive:", isPlaylistActive);
            if (pdfDoc) {
                renderPdfPages();
            }
        }

        /**
         * Renders the songs currently in `currentViewablePlaylistSongs` into the playlist panel UI.
         */
        function renderPlaylist() {
            console.log("[Playlist Render] Rendering playlist items.");
            playlistItemsUl.innerHTML = '';
            playlistTitleElement.textContent = currentPlayingPlaylistName;

            if (currentViewablePlaylistSongs.length === 0) {
                playlistItemsUl.innerHTML = '<li class="p-2 text-gray-500">No songs in playlist.</li>';
                console.log("[Playlist Render] Playlist is empty.");
                return;
            }

            currentViewablePlaylistSongs.forEach((song, index) => {
                const li = document.createElement('li');
                li.className = 'p-2 rounded-md hover:bg-gray-200 cursor-pointer text-gray-800';
                // Add draggable attribute
                li.draggable = true; 
                if (index === currentSongIndexInPlaylist) {
                    li.classList.add('bg-indigo-200', 'font-semibold'); // Highlight current song
                }
                const displayTitle = song.title || removeFileExtension(song.name);
                const displayComposer = song.composer ? ` (${song.composer})` : '';
                li.textContent = `${displayTitle}${displayComposer}`;
                li.dataset.songId = song.id;
                // Make sure to store the full path for PDF.js to use
                li.dataset.filePath = song.file_path ? `/local_pdfs/${song.file_path}` : ''; // Ensure file_path exists

                // Drag and Drop Event Listeners
                li.addEventListener('dragstart', (e) => {
                    draggedItem = li;
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', li.dataset.songId);
                    // Add a class to the body to change cursor globally during drag
                    document.body.classList.add('dragging-active');
                    setTimeout(() => {
                        li.classList.add('opacity-50'); // Hide the dragged item visually
                    }, 0);
                });

                li.addEventListener('dragover', (e) => {
                    e.preventDefault(); // Necessary to allow dropping
                    if (draggedItem && draggedItem !== li) {
                        const boundingBox = li.getBoundingClientRect();
                        const offset = boundingBox.y + (boundingBox.height / 2);
                        // Determine if dragging over top or bottom half of the target item
                        if (e.clientY - offset > 0) {
                            li.classList.remove('border-t-2', 'border-indigo-500');
                            li.classList.add('border-b-2', 'border-indigo-500');
                        } else {
                            li.classList.remove('border-b-2', 'border-indigo-500');
                            li.classList.add('border-t-2', 'border-indigo-500');
                        }
                    }
                });

                li.addEventListener('dragleave', () => {
                    li.classList.remove('border-t-2', 'border-b-2', 'border-indigo-500');
                });

                li.addEventListener('drop', (e) => {
                    e.preventDefault();
                    li.classList.remove('border-t-2', 'border-b-2', 'border-indigo-500');

                    if (draggedItem && draggedItem !== li) {
                        const draggedSongId = draggedItem.dataset.songId;
                        const targetSongId = li.dataset.songId;
                        
                        // Perform reordering logic
                        reorderSong(draggedSongId, targetSongId);
                    }
                });

                li.addEventListener('dragend', () => {
                    draggedItem.classList.remove('opacity-50');
                    draggedItem = null;
                    // Remove the global cursor class
                    document.body.classList.remove('dragging-active');
                    // Clean up any lingering borders from dragover
                    document.querySelectorAll('#playlistItems li').forEach(item => {
                        item.classList.remove('border-t-2', 'border-b-2', 'border-indigo-500');
                    });
                });

                li.addEventListener('click', () => {
                    console.log(`[Playlist Item Click] Clicked song: ${song.name}, ID: ${song.id}, FilePath: ${li.dataset.filePath}`);
                    if (li.dataset.filePath) { // Check if filePath is valid
                        currentSongIndexInPlaylist = index; // Update current song index
                        if (currentPdfUrl === li.dataset.filePath) { // Check if the same PDF is already loaded
                            currentPageNum = 1;
                            console.log("[Playlist Item Click] PDF already loaded. Resetting to page 1.");
                            renderPdfPages();
                        } else {
                            console.log("[Playlist Item Click] Loading new PDF.");
                            loadPdf(li.dataset.filePath);
                        }
                        renderPlaylist(); // Re-render to update highlight
                    } else {
                        showMessage(`PDF path not found for "${displayTitle}".`, 3000);
                        console.error(`[Playlist Item Click] PDF path missing for song ID: ${song.id}`);
                    }
                });
                playlistItemsUl.appendChild(li);
            });
            console.log("[Playlist Render] Playlist items rendered.");
        }

        /**
         * Reorders a song within the playlist, both locally and on the server.
         * @param {string} draggedSongId - The ID of the song being dragged.
         * @param {string} targetSongId - The ID of the song being dropped onto.
         */
        async function reorderSong(draggedSongId, targetSongId) {
            const draggedIdNum = parseInt(draggedSongId, 10);
            const targetIdNum = parseInt(targetSongId, 10);

            const draggedIndex = currentViewablePlaylistSongs.findIndex(s => s.id === draggedIdNum);
            const targetIndex = currentViewablePlaylistSongs.findIndex(s => s.id === targetIdNum);

            if (draggedIndex === -1 || targetIndex === -1) {
                console.error("Dragged or target song not found in playlist array.");
                return;
            }

            // Backup original order in case of server error
            const originalOrder = [...currentViewablePlaylistSongs];

            // Reorder locally for immediate UI update
            const [draggedSong] = currentViewablePlaylistSongs.splice(draggedIndex, 1);
            currentViewablePlaylistSongs.splice(targetIndex, 0, draggedSong);
            
            // Re-render the UI with the new optimistic order
            renderPlaylist();

            // Update the server with the new order
            try {
                const songIds = currentViewablePlaylistSongs.map(s => s.id);
                const response = await fetch(`/api/playlists/${currentPlaylistId}/reorder`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ new_order: songIds })
                });

                if (!response.ok) throw new Error('Failed to save new order to server.');
                
                showMessage("Playlist reordered successfully.", 1500);
            } catch (error) {
                showMessage("Error saving new playlist order. Reverting.", 3000);
                console.error("Error reordering playlist:", error);
                currentViewablePlaylistSongs = originalOrder;
                renderPlaylist();
            }
        }


        // Automatic PDF load on app startup and render initial state of playlist
        document.addEventListener('DOMContentLoaded', async () => {
            const songId = new URLSearchParams(window.location.search).get('songId');
            const playlistId = new URLSearchParams(window.location.search).get('playlistId');

            // If it is a playlist
            if (playlistId) {
                console.log(`[DOMContentLoaded] Found playlistId in URL: ${playlistId}. Loading playlist.`);
                currentPlaylistId = playlistId; // Store the playlist ID
                isPlaylistActive = true;
                try {
                    const response = await fetch(`/api/playlists/${playlistId}`);
                    if (!response.ok) {
                        throw new Error(`API call failed with status: ${response.status}`);
                    }
                    const playlistData = await response.json();
                    
                    currentPlayingPlaylistName = playlistData.name;
                    currentViewablePlaylistSongs = playlistData.songs || [];
                    
                    if (currentViewablePlaylistSongs.length > 0) {
                        currentSongIndexInPlaylist = 0; // Start at the first song
                        const firstSong = currentViewablePlaylistSongs[0];

                        if (firstSong && firstSong.file_path) {
                            const localPdfUrl = `/local_pdfs/${firstSong.file_path}`;
                            await loadPdf(localPdfUrl);
                            // Update last played date for the first song
                            fetch(`/api/library/${firstSong.id}/play`, { method: 'POST' });
                            renderPlaylist(); // Render the playlist UI
                        } else {
                            throw new Error(`First song in playlist "${playlistData.name}" is missing a file path.`);
                        }
                    } else {
                        throw new Error(`Playlist "${playlistData.name}" is empty.`);
                    }
                } catch (error) {
                    console.error("[DOMContentLoaded] Error loading playlist by ID:", error);
                    showMessage(`Error loading playlist: ${error.message}`, 4000);
                    // Clear the view if playlist loading fails
                    pdfDoc = null; // Ensure pdfDoc is null
                    pdfContextLeft.clearRect(0, 0, pdfCanvasLeft.width, pdfCanvasLeft.height);
                    pdfContextRight.clearRect(0, 0, pdfCanvasRight.width, pdfCanvasRight.height);
                    showLoading(false);
                }
            } else if (songId) {
                // Load the song pdf from the server
                console.log(`[DOMContentLoaded] Found songId in URL: ${songId}. Loading as individual song.`);
                isPlaylistActive = false; // Ensure playlist mode is OFF for individual song loads
                playlistContainer.classList.add('hidden'); // Ensure playlist container is hidden
                pageInfoContainer.classList.add('hidden'); // Ensure page info is hidden

                try {
                    console.log(`[DOMContentLoaded] Fetching song details for ID: ${songId}`);
                    const response = await fetch(`/api/library/${songId}`);
                    if (!response.ok) {
                        throw new Error(`API call failed with status: ${response.status}`);
                    }
                    
                    const songDetails = await response.json();
                    console.log(`[DOMContentLoaded] Song details fetched: Name: ${songDetails.name}, File Path: ${songDetails.file_path}`);
                    
                    if (songDetails && songDetails.file_path) {
                        const localPdfUrl = `/local_pdfs/${songDetails.file_path}`;
                        await loadPdf(localPdfUrl);
                        // Also update the last played date
                        fetch(`/api/library/${songId}/play`, { method: 'POST' });
                    } else {
                        throw new Error(`Fetched song details for ID ${songId} are incomplete or missing 'file_path'.`);
                    }
                } catch (error) {
                    console.error("[DOMContentLoaded] Error loading song by ID:", error);
                    showMessage(`Error loading song: ${error.message}`, 4000);
                }
            } else {
                // No specific song or active playlist
                console.log("[DOMContentLoaded] No specific song or active playlist. Displaying initial message.");
                showMessage("No PDF loaded. Please select a song from the Library or play a playlist.", 5000);
                pdfDoc = null;
                pdfContextLeft.clearRect(0, 0, pdfCanvasLeft.width, pdfCanvasLeft.height);
                pdfContextRight.clearRect(0, 0, pdfCanvasRight.width, pdfCanvasRight.height);
                showLoading(false);
            }

            // Hide the playlist button if we are not in an active playlist context.
            if (!isPlaylistActive) {
                playlistsButton.classList.add('hidden');
            }

            console.log("[DOMContentLoaded] App startup routine complete.");
        });
    </script>
</body>
</html>
