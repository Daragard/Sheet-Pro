<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Library</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Apply the Inter font globally */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
            /* Remove tap highlight on mobile */
            background-color: #f3f4f6;
            /* Light gray background */
            color: #374151;
            /* Dark gray text */
        }

        /* Hide scrollbars for a cleaner app-like look */
        body::-webkit-scrollbar {
            display: none;
        }

        body {
            -ms-overflow-style: none;
            /* IE and Edge */
            scrollbar-width: none;
            /* Firefox */
        }

        #qrCodeContainer canvas {
            display: block; /* Removes extra space below the canvas */
        }

        /* --- Share Modal Styles (similar to other modals) --- */
        #shareModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.6);
            /* Semi-transparent black background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s;
        }

        #shareModal.active {
            opacity: 1;
            visibility: visible;
        }

        /* Styling for disabled buttons to indicate their state */
        .button-disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
            /* Disable pointer events on disabled buttons */
        }

        /* Style for library grid items */
        .library-grid-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 1rem;
            border-radius: 0.5rem;
            background-color: #ffffff;
            /* White background for items */
            transition: background-color 0.2s ease-in-out;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            height: 150px;
            /* Fixed height for consistent grid */
            width: 150px;
            /* Fixed width for consistent grid */
            flex-shrink: 0;
            /* Prevent items from shrinking */
        }

        .library-grid-item:hover {
            background-color: #e5e7eb;
        }

        .library-grid-item .icon {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            color: #6366f1;
            /* Indigo color for folder icons */
        }

        .library-grid-item.pdf .icon {
            color: #ef4444;
            /* Red for PDF icons */
        }

        .library-grid-item .name {
            font-weight: 600;
            font-size: 0.9rem;
            color: #374151;
            word-break: break-word;
            /* Ensure long names wrap */
            white-space: normal;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            /* Limit to 2 lines */
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Styles for the options dropdown */
        .options-dropdown {
            position: absolute;
            background-color: #fff;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 10;
            min-width: 160px;
            padding: 0.5rem 0;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: opacity 0.2s ease-out, transform 0.2s ease-out, visibility 0.2s;
            display: none;
            /* Added for reliable hiding */
        }

        .options-dropdown.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
            display: block;
            /* Added for reliable showing */
        }

        /* Styles for buttons inside options dropdown */
        .options-dropdown button {
            display: block;
            /* Ensure buttons take full width and are always visible */
            width: 100%;
            text-align: left;
            padding: 0.75rem 1rem;
            font-size: 0.9rem;
            color: #374151;
            background-color: transparent;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            border-radius: 0.25rem;
            /* Small rounded corners for individual items */
        }

        .options-dropdown button:hover {
            background-color: #f3f4f6;
        }

        .options-dropdown button.active {
            color: #6366f1;
            /* Active color for selected sort option */
            font-weight: 600;
            background-color: #e0e7ff;
            /* Lighter indigo background for active */
        }

        /* Separator line style */
        .options-dropdown hr {
            margin: 0.5rem 0;
            border-color: #e5e7eb;
        }

        /* Styles for tabs */
        .tab-button {
            padding: 0.75rem 1.5rem;
            border-bottom: 2px solid transparent;
            font-weight: 500;
            color: #9ca3af;
            /* Gray text for inactive tab */
            transition: all 0.2s ease-in-out;
        }

        .tab-button:hover {
            color: #e5e7eb;
            /* Lighter gray on hover */
            border-color: #6b7280;
            /* Darker gray border on hover */
        }

        .tab-button.active {
            color: #ffffff;
            /* White text for active tab */
            border-color: #818cf8;
            /* Indigo border for active tab */
            font-weight: 600;
        }

        /* Style for playlist list items */
        .playlist-list-item {
            display: flex;
            align-items: center;
            padding: 1rem;
            margin-bottom: 0.5rem;
            /* Added margin for spacing between items */
            border-radius: 0.5rem;
            background-color: #ffffff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            transition: background-color 0.2s ease-in-out;
            cursor: pointer;
        }

        .playlist-list-item:hover {
            background-color: #e5e7eb;
        }

        .playlist-list-item .icon {
            font-size: 2rem;
            margin-right: 1rem;
            color: #6366f1;
        }

        .playlist-list-item .name {
            font-weight: 600;
            font-size: 1.1rem;
            color: #374151;
            flex-grow: 1;
            /* Allow name to take available space */
        }

        .playlist-list-item .song-count {
            font-size: 0.8rem;
            color: #6b7280;
            margin-left: auto;
        }

        /* Style for a custom message box */
        #messageBox {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            pointer-events: none;
        }

        #messageBox.active {
            opacity: 1;
        }

        /* --- Song Details Modal Styles --- */
        #songDetailsModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.6);
            /* Semi-transparent black background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s;
        }

        #songDetailsModal.active {
            opacity: 1;
            visibility: visible;
        }

        #songDetailsModalContent {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 900px;
            height: 80%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #songDetailsModalHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background-color: #6366f1;
            /* Indigo header */
            color: white;
            border-top-left-radius: 1rem;
            border-top-right-radius: 1rem;
        }

        #songDetailsModalBody {
            display: flex;
            flex: 1;
            /* Takes remaining height */
            overflow: hidden;
        }

        #songDetailsSidebar {
            width: 200px;
            /* Fixed width for sidebar */
            background-color: #f3f4f6;
            /* Light gray for sidebar */
            padding: 1rem 0;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #e5e7eb;
        }

        #songDetailsSidebar button {
            display: block;
            width: 100%;
            padding: 1rem 1.5rem;
            text-align: left;
            font-weight: 500;
            color: #374151;
            background-color: transparent;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
        }

        #songDetailsSidebar button:hover {
            background-color: #e0e7ff;
            color: #4338ca;
            /* Darker indigo on hover */
        }

        #songDetailsSidebar button.active {
            background-color: #cbd5e1;
            /* Even lighter indigo for active */
            color: #1f2937;
            /* Darker text for active */
            font-weight: 600;
            border-left: 4px solid #6366f1;
            /* Active indicator bar */
        }

        #songDetailsContentArea {
            flex: 1;
            /* Takes remaining width */
            padding: 1.5rem;
            overflow-y: auto;
            /* Scroll for content if needed */
        }

        /* Styles for metadata form/display */
        .metadata-item {
            margin-bottom: 1rem;
        }

        .metadata-item label {
            display: block;
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 0.25rem;
            font-size: 0.9rem;
        }

        .metadata-item p,
        .metadata-item input,
        .metadata-item textarea {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            color: #1f2937;
            width: 100%;
            /* Make inputs take full width */
        }

        .metadata-item input:disabled,
        .metadata-item textarea:disabled {
            background-color: #e5e7eb;
            /* Slightly darker background for disabled inputs */
            cursor: default;
        }

        .metadata-actions {
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
        }

        .metadata-actions button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .metadata-actions button.primary {
            background-color: #6366f1;
            color: white;
        }

        .metadata-actions button.primary:hover {
            background-color: #4f46e5;
        }

        .metadata-actions button.secondary {
            background-color: #e5e7eb;
            color: #374151;
        }

        .metadata-actions button.secondary:hover {
            background-color: #d1d5db;
        }

        /* Styles for Playlists in modal */
        #modalPlaylistsList {
            margin-top: 1rem;
        }

        /* Adjusted style for items in songInPlaylistsList for better layout with remove button */
        #songInPlaylistsList .playlist-item-with-remove {
            display: flex;
            align-items: center;
            justify-content: space-between;
            /* Space out name and button */
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            font-size: 0.9rem;
            color: #374151;
        }

        #songInPlaylistsList .playlist-item-with-remove button {
            background-color: #ef4444;
            /* Red for remove */
            color: white;
            padding: 0.3rem 0.6rem;
            border-radius: 0.25rem;
            font-size: 0.8rem;
            transition: background-color 0.2s ease-in-out;
        }

        #songInPlaylistsList .playlist-item-with-remove button:hover {
            background-color: #dc2626;
            /* Darker red on hover */
        }


        /* Add to Playlist section in modal */
        #addToPlaylistSection {
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid #e5e7eb;
        }

        #addToPlaylistSection h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #4b5563;
        }

        #addPlaylistsDropdown {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            background-color: #fff;
        }

        #addPlaylistsDropdown button {
            display: block;
            width: 100%;
            text-align: left;
            padding: 0.75rem 1rem;
            font-size: 0.9rem;
            color: #374151;
            background-color: transparent;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            border-radius: 0;
        }

        #addPlaylistsDropdown button:hover {
            background-color: #f3f4f6;
        }

        /* --- Change Path Modal Styles --- */
        #changePathModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s;
        }

        #changePathModal.active {
            opacity: 1;
            visibility: visible;
        }

        #changePathModal code {
            background-color: #f3f4f6;
            padding: 0.5rem;
            border-radius: 0.25rem;
            display: block;
            margin-bottom: 1rem;
            font-family: monospace;
            color: #4b5563;
        }

        #changePathModal input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
        }
    </style>
</head>

<body class="h-screen w-screen flex flex-col p-4 gap-4">

    <!-- Main Library Content -->
    <div id="libraryMainContent" class="flex-1 flex flex-col p-4 bg-white rounded-xl shadow-lg h-full overflow-x-auto">
        <!-- Header for Library View -->
        <header class="p-4 bg-gray-900 text-white shadow-lg rounded-t-lg">
            <div class="grid grid-cols-3 items-center">
                <!-- Left side: Navigation buttons -->
                <div id="navButtonContainer" class="flex items-center space-x-2 justify-start">
                    <button id="homeButton"
                        class="p-2 rounded-full hover:bg-gray-700 transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                        <i class="fas fa-home text-lg"></i>
                    </button>
                    <button id="backButton"
                        class="p-2 rounded-full hover:bg-gray-700 transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                        <i class="fas fa-arrow-left text-lg"></i>
                    </button>
                    <button id="forwardButton"
                        class="p-2 rounded-full hover:bg-gray-700 transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                        <i class="fas fa-arrow-right text-lg"></i>
                    </button>
                    <button id="upButton"
                        class="p-2 rounded-full hover:bg-gray-700 transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                        <i class="fas fa-level-up-alt text-lg"></i>
                    </button>
                </div>

                <!-- Center: Tabs -->
                <div class="flex justify-center">
                    <button id="libraryTabButton" class="tab-button active justify-start">Library</button>
                    <button id="playlistsTabButton" class="tab-button justify-end">Playlists</button>
                </div>

                <!-- Right side: Options button -->
                <div id="optionsButtonContainer" class="flex items-center justify-end space-x-2">
                    <button id="shareButton"
                        class="px-4 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-700 transition-colors text-sm font-medium text-white focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                        Remote Connect
                    </button>
                    <div class="relative">
                        <button id="optionsButton"
                            class="p-2 rounded-full hover:bg-gray-700 transition-colors text-sm font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                            <i class="fas fa-ellipsis-h text-lg"></i>
                        </button>

                        <!-- Options Dropdown Menu -->
                        <div id="optionsDropdown" class="options-dropdown top-full right-0">
                            <button id="alphabeticalSortButton" data-sort-order="alphabetical">Alphabetical</button>
                            <button id="dateCreatedSortButton" data-sort-order="dateCreated">Date Created</button>
                            <button id="dateLastPlayedSortButton" data-sort-order="dateLastPlayed">Date Last
                                Played</button>
                            <hr class="border-gray-200 my-1">
                            <button id="changeLibraryFolderButton">Change Library Folder</button>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <!-- Main Content Area: Library View -->
        <div id="libraryView" class="flex-1 flex flex-col pt-4 h-full">
            <!-- Scan Library Section (hidden by default) -->
            <div id="scanLibrarySection"
                class="flex flex-col items-center justify-center h-full text-center p-8 bg-gray-50 rounded-lg shadow-inner hidden">
                <i class="fas fa-folder-open text-6xl text-gray-400 mb-4"></i>
                <p id="emptyLibraryMessage" class="text-xl font-semibold text-gray-700 mb-4">Your library is empty.</p>
                <p id="emptyLibraryHint" class="text-gray-600 mb-6">Click the button below to scan your configured PDF
                    folder and populate your library, or change the folder location.</p>
                <button id="actionButton"
                    class="px-6 py-3 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 text-lg">
                    <i class="fas fa-sync-alt mr-2" id="actionButtonIcon"></i> <span id="actionButtonText">Scan Library
                        Folder</span>
                </button>
            </div>

            <!-- Library Grid -->
            <div id="libraryGrid" class="grid grid-cols-6 mt-6 gap-x-4 gap-y-4 overflow-y-auto pb-4 px-4">
                <!-- Library items will be dynamically inserted here -->
            </div>
        </div>

        <!-- Main Content Area: Playlists View (initially hidden) -->
        <div id="playlistsView" class="flex-1 flex flex-col pt-4 h-full hidden">
            <h2 class="text-xl font-bold text-gray-800 mb-4 px-4">My Playlists</h2>
            <div id="playlistsList" class="flex flex-col gap-2 overflow-y-auto pb-4 px-4">
                <!-- Playlists will be dynamically inserted here -->
            </div>
            <button id="createNewPlaylistButton"
                class="mt-4 mx-4 px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                <i class="fas fa-plus mr-2"></i>Create New Playlist
            </button>
        </div>
    </div>

    <!-- Song Details Modal -->
    <div id="songDetailsModal" class="hidden">
        <div id="songDetailsModalContent">
            <header id="songDetailsModalHeader">
                <h2 id="modalSongTitle" class="text-xl font-bold">Song Title</h2>
                <button id="closeModalButton" class="text-white hover:text-gray-200 text-2xl">
                    <i class="fas fa-times"></i>
                </button>
            </header>
            <div id="songDetailsModalBody">
                <aside id="songDetailsSidebar">
                    <!-- Swapped order of tabs -->
                    <button id="playlistsTabButtonModal" class="active">Playlists</button>
                    <button id="metadataTabButton">Metadata</button>
                </aside>
                <main id="songDetailsContentArea">
                    <!-- Swapped order of tab content divs -->
                    <div id="playlistsContentModal" class="tab-content">
                        <h3 class="text-lg font-semibold text-gray-700 mb-4">In These Playlists</h3>
                        <div id="songInPlaylistsList" class="flex flex-col gap-2">
                            <p class="text-gray-600">Loading playlists...</p>
                        </div>

                        <div id="addToPlaylistSection">
                            <h3>Add to another Playlist</h3>
                            <div id="addPlaylistsDropdown">
                                <!-- Playlists to add to dynamically loaded here -->
                            </div>
                        </div>
                    </div>

                    <div id="metadataContent" class="tab-content hidden">
                        <h3 class="text-lg font-semibold text-gray-700 mb-4">Song Metadata</h3>
                        <div class="metadata-item">
                            <label for="inputMetadataFilename">Filename:</label>
                            <input type="text" id="inputMetadataFilename" disabled>
                        </div>
                        <div class="metadata-item">
                            <label for="inputMetadataTitle">Title:</label>
                            <input type="text" id="inputMetadataTitle">
                        </div>
                        <div class="metadata-item">
                            <label for="inputMetadataComposer">Composer:</label>
                            <input type="text" id="inputMetadataComposer">
                        </div>
                        <div class="metadata-item">
                            <label for="inputMetadataGenre">Genre:</label>
                            <input type="text" id="inputMetadataGenre">
                        </div>
                        <div class="metadata-item">
                            <label for="inputMetadataTag">Tag:</label>
                            <input type="text" id="inputMetadataTag">
                        </div>
                        <div class="metadata-item">
                            <label for="inputMetadataLabel">Label:</label>
                            <input type="text" id="inputMetadataLabel">
                        </div>
                        <div class="metadata-item">
                            <label for="inputMetadataRating">Rating:</label>
                            <input type="text" id="inputMetadataRating">
                        </div>
                        <div class="metadata-item">
                            <label for="inputMetadataDifficulty">Difficulty:</label>
                            <input type="text" id="inputMetadataDifficulty">
                        </div>
                        <div class="metadata-item">
                            <label for="inputMetadataPlaytime">Playtime:</label>
                            <input type="text" id="inputMetadataPlaytime" placeholder="00:00">
                        </div>
                        <div class="metadata-item">
                            <label for="inputMetadataKey">Key:</label>
                            <input type="text" id="inputMetadataKey">
                        </div>
                        <div class="metadata-item">
                            <label for="inputMetadataTime">Time Signature:</label>
                            <input type="text" id="inputMetadataTime">
                        </div>
                        <div class="metadata-item">
                            <label for="inputMetadataDateCreated">Date Created:</label>
                            <input type="text" id="inputMetadataDateCreated" disabled>
                        </div>
                        <div class="metadata-item">
                            <label for="inputMetadataLastPlayed">Last Played:</label>
                            <input type="text" id="inputMetadataLastPlayed" disabled>
                        </div>
                        <div class="metadata-actions">
                            <!-- Removed save, cancel, rename, and open in viewer buttons -->
                        </div>
                    </div>
                </main>
            </div>
        </div>
    </div>

    <!-- Change Library Path Modal -->
    <div id="changePathModal" class="hidden">
        <div class="bg-white rounded-lg shadow-xl w-11/12 max-w-lg flex flex-col">
            <header class="flex items-center justify-between p-4 border-b border-gray-200">
                <h2 class="text-xl font-bold text-gray-800">Change Library Folder</h2>
                <button id="closeChangePathModalButton"
                    class="text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
            </header>
            <main class="p-6">
                <p class="text-gray-600 mb-4">
                    Please enter the full, absolute path to the folder on your computer where your sheet music PDFs are
                    stored.
                </p>
                <p class="text-sm text-gray-500 mb-1">Example for Windows:</p>
                <code>C:\Users\YourName\Documents\Sheet Music</code>
                <p class="text-sm text-gray-500 mb-1">Example for macOS/Linux:</p>
                <code>/home/yourname/Music/Scores</code>
                <input type="text" id="newPathInput" placeholder="Enter full folder path here...">
            </main>
            <footer class="p-4 bg-gray-50 border-t border-gray-200 flex justify-end items-center gap-4">
                <button id="cancelChangePathButton"
                    class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Cancel</button>
                <button id="saveNewPathButton"
                    class="px-6 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Save and Rescan</button>
            </footer>
        </div>
    </div>

    <!-- Share Modal -->
    <div id="shareModal" class="hidden">
        <div class="bg-white rounded-lg shadow-xl w-11/12 max-w-sm flex flex-col">
            <header class="flex items-center justify-between p-4 border-b border-gray-200">
                <h2 class="text-xl font-bold text-gray-800">Share Server Address</h2>
                <button id="closeShareModalButton"
                    class="text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
            </header>
            <main class="p-6 flex flex-col items-center">
                <p class="text-gray-600 mb-4 text-center">
                    Scan this QR code or copy the link to access this server from another device on the same network.
                </p>
                <div id="qrCodeContainer" class="mb-4 p-2 border rounded-lg bg-white">
                    <!-- QR code will be generated here -->
                </div>
                <div class="w-full">
                    <p class="text-sm text-gray-500 mb-1">Server Address:</p>
                    <div class="flex items-center border border-gray-300 rounded-md p-2 bg-gray-50">
                        <input type="text" id="serverLinkInput" readonly
                            class="flex-grow bg-transparent outline-none border-none text-gray-700">
                        <button id="copyLinkButton" class="ml-2 text-gray-500 hover:text-indigo-600">
                            <i class="fas fa-copy"></i>
                        </button>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Message box for user feedback -->
    <div id="messageBox"
        class="fixed bottom-8 left-4 right-4 bg-gray-800 text-white px-6 py-3 rounded-lg shadow-lg opacity-0 transition-opacity duration-300 pointer-events: none; z-50">
    </div>

    <script>
        // --- DOM Element References ---
        // QR Code library
        const qrCodeScript = document.createElement('script');
        qrCodeScript.src = 'https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js';
        document.head.appendChild(qrCodeScript);
        const messageBox = document.getElementById('messageBox');
        const libraryMainContent = document.getElementById('libraryMainContent');
        const libraryGrid = document.getElementById('libraryGrid');
        const scanLibrarySection = document.getElementById('scanLibrarySection');
        const actionButton = document.getElementById('actionButton'); // Unified button
        const actionButtonIcon = document.getElementById('actionButtonIcon');
        const actionButtonText = document.getElementById('actionButtonText');
        const emptyLibraryMessage = document.getElementById('emptyLibraryMessage');
        const emptyLibraryHint = document.getElementById('emptyLibraryHint');

        // Navigation buttons
        const homeButton = document.getElementById('homeButton');
        const backButton = document.getElementById('backButton');
        const forwardButton = document.getElementById('forwardButton');
        const upButton = document.getElementById('upButton');
        const optionsButton = document.getElementById('optionsButton');
        const navButtonContainer = document.getElementById('navButtonContainer');
        const optionsDropdown = document.getElementById('optionsDropdown');
        const optionsButtonContainer = document.getElementById('optionsButtonContainer');

        // Sorting buttons (inside the dropdown)
        const alphabeticalSortButton = document.getElementById('alphabeticalSortButton');
        const dateCreatedSortButton = document.getElementById('dateCreatedSortButton');
        const dateLastPlayedSortButton = document.getElementById('dateLastPlayedSortButton');
        const changeLibraryFolderButton = document.getElementById('changeLibraryFolderButton'); // New button

        // View tabs
        const libraryTabButton = document.getElementById('libraryTabButton');
        const playlistsTabButton = document.getElementById('playlistsTabButton');
        const libraryView = document.getElementById('libraryView');
        const playlistsView = document.getElementById('playlistsView');
        const playlistsList = document.getElementById('playlistsList');
        const createNewPlaylistButton = document.getElementById('createNewPlaylistButton');

        // Song Details Modal elements
        const songDetailsModal = document.getElementById('songDetailsModal');
        const closeModalButton = document.getElementById('closeModalButton');
        const modalSongTitle = document.getElementById('modalSongTitle');
        const metadataTabButton = document.getElementById('metadataTabButton');
        const playlistsTabButtonModal = document.getElementById('playlistsTabButtonModal');
        const metadataContent = document.getElementById('metadataContent');
        const playlistsContentModal = document.getElementById('playlistsContentModal');
        // Renamed and Open in Viewer buttons are removed
        const songInPlaylistsList = document.getElementById('songInPlaylistsList');
        const addPlaylistsDropdown = document.getElementById('addPlaylistsDropdown');

        // New metadata input references
        const inputMetadataFilename = document.getElementById('inputMetadataFilename'); // Renamed from inputMetadataName
        const inputMetadataTitle = document.getElementById('inputMetadataTitle');
        const inputMetadataComposer = document.getElementById('inputMetadataComposer');
        const inputMetadataGenre = document.getElementById('inputMetadataGenre');
        const inputMetadataTag = document.getElementById('inputMetadataTag');
        const inputMetadataLabel = document.getElementById('inputMetadataLabel');
        const inputMetadataRating = document.getElementById('inputMetadataRating');
        const inputMetadataDifficulty = document.getElementById('inputMetadataDifficulty');
        const inputMetadataPlaytime = document.getElementById('inputMetadataPlaytime');
        const inputMetadataKey = document.getElementById('inputMetadataKey');
        const inputMetadataTime = document.getElementById('inputMetadataTime');
        const inputMetadataDateCreated = document.getElementById('inputMetadataDateCreated');
        const inputMetadataLastPlayed = document.getElementById('inputMetadataLastPlayed');

        // Change Path Modal elements
        const changePathModal = document.getElementById('changePathModal');
        const closeChangePathModalButton = document.getElementById('closeChangePathModalButton');
        const cancelChangePathButton = document.getElementById('cancelChangePathButton');
        const saveNewPathButton = document.getElementById('saveNewPathButton');
        const newPathInput = document.getElementById('newPathInput');

        // Share Modal elements
        const shareButton = document.getElementById('shareButton');
        const shareModal = document.getElementById('shareModal');
        const closeShareModalButton = document.getElementById('closeShareModalButton');
        const qrCodeContainer = document.getElementById('qrCodeContainer');
        const serverLinkInput = document.getElementById('serverLinkInput');
        const copyLinkButton = document.getElementById('copyLinkButton');

        // --- State Variables ---
        let currentLibraryPath = []; // Array of folder names representing the current path for Library view
        let currentSortOrder = 'alphabetical'; // Default sort order for library
        let navigationHistory = [];
        let historyIndex = -1;
        let currentView = 'library'; // 'library' or 'playlists'
        let selectedItemForModal = null; // Stores the PDF item clicked for modal
        let libraryData = null; // Will be fetched from server
        let playlistsData = []; // Will be fetched from server
        // No longer need originalMetadataValues as changes save automatically


        // --- Utility Functions ---
        function showMessage(message, duration = 3000) {
            messageBox.textContent = message;
            messageBox.classList.remove('opacity-0');
            messageBox.classList.add('opacity-100');
            setTimeout(() => {
                messageBox.classList.remove('opacity-100');
                messageBox.classList.add('opacity-0');
            }, duration);
        }

        /**
         * Function to remove a file extension from a string.
         * @param {string} filename - The filename with or without an extension.
         * @returns {string} The filename without its extension.
         */
        function removeFileExtension(filename) {
            const lastDotIndex = filename.lastIndexOf('.');
            if (lastDotIndex === -1) {
                return filename; // No extension found
            }
            // Check if it's a hidden file (e.g., .htaccess) or just a dot
            if (lastDotIndex === 0 || lastDotIndex === filename.length - 1) {
                return filename;
            }
            return filename.substring(0, lastDotIndex);
        }

        /**
         * Fetches the entire library data from the Flask API.
         * @returns {Promise<object>} The library data.
         */
        async function fetchLibraryData() {
            try {
                const response = await fetch('/api/library');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                libraryData = data; // Store the fetched data globally
                return data;
            }
            catch (error) {
                console.error("Error fetching library data:", error);
                showMessage("Failed to load library data.", 3000);
                return { name: "Root", type: "folder", contents: [] }; // Return empty structure on error
            }
        }

        /**
         * Finds a folder/item in the library data given a path.
         * @param {Array<string>} path - An array of folder names representing the path.
         * @returns {object|null} The folder/item object, or null if not found.
         */
        function getFolderByPath(path) {
            let currentFolder = libraryData;
            if (!currentFolder) return null;

            // The root in `libraryData` is "Root", whose contents are the top-level items.
            // We need to drill down into its 'contents'
            let traverseContents = currentFolder.contents;

            for (const name of path) {
                const found = traverseContents.find(item => item.name === name && item.type === "folder");
                if (found) {
                    currentFolder = found;
                    traverseContents = currentFolder.contents; // Update contents for next level
                } else {
                    return null; // Path segment not found
                }
            }
            return currentFolder;
        }

        /**
         * Renders the items (folders and PDFs) in the current library path.
         */
        async function renderLibraryGrid() {
            if (!libraryData) {
                await fetchLibraryData(); // Ensure libraryData is loaded
            }

            libraryGrid.innerHTML = ''; // Clear existing items

            const currentFolder = getFolderByPath(currentLibraryPath);
            if (!currentFolder || !currentFolder.contents || currentFolder.contents.length === 0) {
                // If library is empty or current folder has no contents, show scan/change path prompt
                scanLibrarySection.classList.remove('hidden');
                libraryGrid.classList.add('hidden'); // Hide the grid container

                // Adjust button text and icon for empty library
                actionButtonIcon.className = 'fas fa-folder-open mr-2'; // Change icon to folder-open
                actionButtonText.textContent = 'Change Library Folder';
                emptyLibraryMessage.textContent = 'Your library folder is currently empty or not set.';
                emptyLibraryHint.textContent = 'Click the button below to specify a new folder location.';

                // Set the handler for the action button to change path
                actionButton.onclick = handleChangeLibraryFolder;

                return;
            } else {
                scanLibrarySection.classList.add('hidden'); // Hide scan prompt
                libraryGrid.classList.remove('hidden'); // Show the grid container
            }

            let itemsToRender = [...currentFolder.contents]; // Create a shallow copy to sort

            // Apply sorting
            itemsToRender.sort((a, b) => {
                if (a.type === 'folder' && b.type !== 'folder') return -1; // Folders first
                if (a.type !== 'folder' && b.type === 'folder') return 1;

                switch (currentSortOrder) {
                    case 'alphabetical':
                        return a.name.localeCompare(b.name);
                    case 'dateCreated':
                        return new Date(b.date_created) - new Date(a.date_created); // Newest first
                    case 'dateLastPlayed':
                        return new Date(b.date_last_played) - new Date(a.date_last_played); // Most recent first
                    default:
                        return 0;
                }
            });

            itemsToRender.forEach(item => {
                const itemElement = document.createElement('div');
                itemElement.className = 'library-grid-item';

                if (item.type === 'folder') {
                    itemElement.innerHTML = `
                        <i class="fas fa-folder icon"></i>
                        <span class="name">${item.name}</span>
                    `;
                    itemElement.addEventListener('click', () => navigateToFolder(item.name));
                } else if (item.type === 'pdf') {
                    // Use item.title if available, otherwise filename without extension
                    const displayName = item.title || removeFileExtension(item.name);
                    itemElement.innerHTML = `
                        <i class="fas fa-file-pdf icon pdf"></i>
                        <span class="name">${displayName}</span>
                    `;
                    // Open modal on right-click/long-press
                    itemElement.addEventListener('contextmenu', (event) => openSongDetailsModal(event, item.id, item.name));
                    itemElement.addEventListener('touchstart', (event) => startLongPress(event, item.id, item.name));
                    itemElement.addEventListener('touchend', endLongPress);
                    itemElement.addEventListener('touchcancel', endLongPress);

                    itemElement.addEventListener('click', () => openPdfFromLibrary(item.id)); // Pass item ID
                }
                libraryGrid.appendChild(itemElement);
            });

            updateSortButtonStyles(); // Update button styles
            updateNavigationButtonStates(); // Update navigation button states

            // When content is present, ensure the action button reverts to "Scan Library Folder"
            actionButtonIcon.className = 'fas fa-sync-alt mr-2'; // Revert icon
            actionButtonText.textContent = 'Scan Library Folder';
            actionButton.onclick = handleScanLibrary; // Revert handler
        }

        /**
         * Navigates into a specified folder within the library.
         * @param {string} folderName - The name of the folder to navigate into.
         */
        function navigateToFolder(folderName) {
            currentLibraryPath.push(folderName);
            saveCurrentPathToHistory(); // Save the new path to history
            renderLibraryGrid();
        }

        /**
         * Navigates backward in the browsing history.
         */
        function goBackInHistory() {
            if (historyIndex > 0) {
                historyIndex--;
                currentLibraryPath = [...navigationHistory[historyIndex]];
                renderLibraryGrid();
            } else {
                showMessage("No backward history.", 2000);
            }
            updateNavigationButtonStates(); // Always update states
        }

        /**
         * Navigates forward in the browsing history.
         */
        function goForwardInHistory() {
            if (historyIndex < navigationHistory.length - 1) {
                historyIndex++;
                currentLibraryPath = [...navigationHistory[historyIndex]];
                renderLibraryGrid();
            } else {
                showMessage("No forward history.", 2000);
            }
            updateNavigationButtonStates(); // Always update states
        }

        /**
         * Goes up one level in the library folder hierarchy.
         */
        function goUpOneLevel() {
            if (currentLibraryPath.length > 0) {
                currentLibraryPath.pop();
                saveCurrentPathToHistory(); // Save the new (parent) path
                renderLibraryGrid();
            } else {
                showMessage("You are already at the root.", 2000);
            }
        }

        /**
         * Saves the current library path to the navigation history.
         */
        function saveCurrentPathToHistory() {
            // Only save if the current path is different from the last saved path
            if (historyIndex === -1 || JSON.stringify(navigationHistory[historyIndex]) !== JSON.stringify(currentLibraryPath)) {
                // Clear forward history if we navigate to a new path
                if (historyIndex < navigationHistory.length - 1) {
                    navigationHistory = navigationHistory.slice(0, historyIndex + 1);
                }
                navigationHistory.push([...currentLibraryPath]);
                historyIndex = navigationHistory.length - 1;
            }
            updateNavigationButtonStates(); // Update button states after history change
        }

        /**
         * Updates the enabled/disabled state of navigation buttons.
         */
        function updateNavigationButtonStates() {
            backButton.disabled = historyIndex <= 0;
            forwardButton.disabled = historyIndex >= navigationHistory.length - 1;
            upButton.disabled = currentLibraryPath.length === 0;

            if (backButton.disabled) {
                backButton.classList.add('button-disabled');
            } else {
                backButton.classList.remove('button-disabled');
            }

            if (forwardButton.disabled) {
                forwardButton.classList.add('button-disabled');
            } else {
                forwardButton.classList.remove('button-disabled');
            }

            if (upButton.disabled) {
                upButton.classList.add('button-disabled');
            } else {
                upButton.classList.remove('button-disabled');
            }
        }


        /**
         * Opens a PDF from the library by passing its ID to index.html.
         * @param {number} itemId - The ID of the PDF item to open.
         */
        function openPdfFromLibrary(songId) {
            window.location.href = 'index.html?songId=' + songId;
        }

        /**
         * Sorts the library items based on the given sort order.
         * @param {string} order - 'alphabetical', 'dateCreated', or 'dateLastPlayed'.
         */
        function sortLibrary(order) {
            currentSortOrder = order;
            renderLibraryGrid();
            optionsDropdown.classList.remove('active'); // Close dropdown after selection
        }

        // Function to correctly manage active/inactive button styles for sorting tabs
        function updateSortButtonStyles() {
            const sortButtons = {
                'alphabetical': alphabeticalSortButton,
                'dateCreated': dateCreatedSortButton,
                'dateLastPlayed': dateLastPlayedSortButton
            };

            for (const key in sortButtons) {
                const button = sortButtons[key];
                // Remove all specific active/inactive styling classes
                button.classList.remove('active');

                if (key === currentSortOrder) {
                    // Apply active styles
                    button.classList.add('active');
                }
            }
        }

        /**
         * Switches between library and playlist views.
         * @param {string} viewName - 'library' or 'playlists'.
         */
        async function switchView(viewName) {
            currentView = viewName;
            if (currentView === 'library') {
                libraryView.classList.remove('hidden');
                playlistsView.classList.add('hidden');
                libraryTabButton.classList.add('active');
                playlistsTabButton.classList.remove('active');
                navButtonContainer.classList.remove('invisible'); // Show nav buttons for library
                optionsButtonContainer.classList.remove('invisible'); // Show options for library
                await renderLibraryGrid(); // Re-render library grid on switch
            } else {
                libraryView.classList.add('hidden');
                playlistsView.classList.remove('hidden');
                libraryTabButton.classList.remove('active');
                playlistsTabButton.classList.add('active');
                navButtonContainer.classList.add('invisible'); // Hide nav buttons for playlists
                optionsButtonContainer.classList.add('invisible'); // Hide options for playlists
                await fetchPlaylistsData(); // Fetch playlists before rendering
                renderPlaylistsList(); // Render playlists on switch
            }
            optionsDropdown.classList.remove('active'); // Close options dropdown if visible when switching views
        }

        /**
         * Fetches all playlists from the Flask API.
         */
        async function fetchPlaylistsData() {
            try {
                const response = await fetch('/api/playlists');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                playlistsData = data; // Store the fetched playlists globally
            } catch (error) {
                console.error("Error fetching playlists data:", error);
                showMessage("Failed to load playlists.", 3000);
                playlistsData = []; // Clear playlists on error
            }
        }

        /**
         * Renders the list of playlists in the playlists view.
         */
        function renderPlaylistsList() {
            playlistsList.innerHTML = '';
            if (playlistsData.length === 0) {
                playlistsList.innerHTML = '<p class="text-gray-600 px-4">No playlists yet. Create a new one!</p>';
                return;
            }

            playlistsData.forEach(playlist => {
                const playlistElement = document.createElement('div');
                playlistElement.className = 'playlist-list-item';

                // Clickable area for navigation
                const clickableArea = document.createElement('div');
                clickableArea.className = 'flex items-center flex-grow cursor-pointer';
                clickableArea.innerHTML = `
                    <i class="fas fa-music icon"></i>
                    <span class="name">${playlist.name}</span>
                    <span class="song-count">${playlist.song_count} songs</span>
                `;
                clickableArea.addEventListener('click', () => openPlaylistDetail(playlist.id));

                // Delete button
                const deleteButton = document.createElement('button');
                deleteButton.className = 'ml-4 p-2 text-red-500 hover:text-red-700 rounded-full hover:bg-red-100 transition-colors';
                deleteButton.innerHTML = '<i class="fas fa-trash-alt"></i>';
                deleteButton.title = 'Delete Playlist';
                deleteButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleDeletePlaylist(playlist.id, playlist.name);
                });

                playlistElement.appendChild(clickableArea);
                playlistElement.appendChild(deleteButton);
                playlistsList.appendChild(playlistElement);
            });
        }

        /**
         * Opens a new HTML page to display the details of a specific playlist.
         * @param {number} playlistId - The ID of the playlist to open.
         */
        function openPlaylistDetail(playlistId) {
            window.location.href = `playlist.html?playlistId=${playlistId}`;
        }

        /**
         * Handles the deletion of a playlist.
         * @param {number} playlistId - The ID of the playlist to delete.
         * @param {string} playlistName - The name of the playlist for the confirmation dialog.
         */
        async function handleDeletePlaylist(playlistId, playlistName) {
            if (!confirm(`Are you sure you want to delete the playlist "${playlistName}"? This cannot be undone.`)) {
                return;
            }

            try {
                const response = await fetch(`/api/playlists/${playlistId}`, { method: 'DELETE' });
                const result = await response.json();

                if (!response.ok) throw new Error(result.error || 'Could not delete playlist.');

                showMessage(result.message, 2500);
                await fetchPlaylistsData();
                renderPlaylistsList();
            } catch (error) {
                console.error("Error deleting playlist:", error);
                showMessage(`Error: ${error.message}`, 4000);
            }
        }

        /**
         * Displays the song details modal.
         * @param {Event} event - The mouse or touch event.
         * @param {number} itemId - The ID of the library item (PDF) clicked.
         * @param {string} itemName - The name of the library item (PDF) clicked.
         */
        async function openSongDetailsModal(event, itemId, itemName) {
            event.preventDefault(); // Prevent default context menu behavior
            selectedItemForModal = { id: itemId, name: itemName }; // Store the item ID and name

            modalSongTitle.textContent = itemName; // Set modal title

            // Fetch the full item details including dates for metadata tab
            try {
                const response = await fetch(`/api/library/${itemId}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const itemDetails = await response.json();

                // Populate metadata fields
                inputMetadataFilename.value = itemDetails.name || '';
                // Default title to filename without extension if no title is provided
                inputMetadataTitle.value = itemDetails.title || removeFileExtension(itemDetails.name) || '';
                inputMetadataComposer.value = itemDetails.composer || '';
                inputMetadataGenre.value = itemDetails.genre || '';
                inputMetadataTag.value = itemDetails.tag || '';
                inputMetadataLabel.value = itemDetails.label || '';
                inputMetadataRating.value = itemDetails.rating || '';
                inputMetadataDifficulty.value = itemDetails.difficulty || '';
                inputMetadataPlaytime.value = itemDetails.playtime || '';
                inputMetadataTime.value = itemDetails.time || '';
                inputMetadataKey.value = itemDetails.key || '';

                // For date fields, parse and format for consistency
                inputMetadataDateCreated.value = itemDetails.date_created ? new Date(itemDetails.date_created).toLocaleString() : '';
                inputMetadataLastPlayed.value = itemDetails.date_last_played ? new Date(itemDetails.date_last_played).toLocaleString() : '';

                // No longer store originalMetadataValues as there's no explicit cancel button
            } catch (error) {
                console.error("Error fetching song details for modal:", error);
                showMessage("Could not load song details.", 3000);
                // Clear inputs and set placeholders/error messages
                inputMetadataFilename.value = itemName; // Keep original filename
                inputMetadataTitle.value = removeFileExtension(itemName); // Default to cleaned filename
                inputMetadataComposer.value = 'Error loading';
                inputMetadataGenre.value = 'Error loading';
                inputMetadataTag.value = 'Error loading';
                inputMetadataLabel.value = 'Error loading';
                inputMetadataRating.value = 'Error loading';
                inputMetadataDifficulty.value = 'Error loading';
                inputMetadataTime.value = 'Error loading';
                inputMetadataKey.value = 'Error loading';
                inputMetadataDateCreated.value = 'Error loading';
                inputMetadataLastPlayed.value = 'Error loading';
            }

            // Initially show playlists tab
            switchSongDetailsTab('playlists'); // Changed to 'playlists'
            songDetailsModal.classList.add('active'); // Show the modal
        }

        /**
         * Saves metadata changes via API.
         * This function is now triggered on blur of metadata input fields.
         */
        async function saveMetadataChanges() {
            if (!selectedItemForModal) {
                console.warn("No item selected for saving metadata. Skipping save.");
                return;
            }

            // --- Validation ---
            const ratingValue = inputMetadataRating.value.trim();
            if (ratingValue && (isNaN(ratingValue) || !Number.isFinite(parseFloat(ratingValue)))) {
                showMessage("Invalid Rating: Please enter a number.", 3000);
                inputMetadataRating.focus(); // Put focus back on the invalid field
                return; // Stop the save
            }

            const playtimeValue = inputMetadataPlaytime.value.trim();
            const playtimeRegex = /^\d{1,2}:\d{2}$/;
            if (playtimeValue && !playtimeRegex.test(playtimeValue)) {
                showMessage("Invalid Playtime: Please use MM:SS format.", 3000);
                inputMetadataPlaytime.focus(); // Put focus back on the invalid field
                return; // Stop the save
            }

            const updatedMetadata = {
                title: inputMetadataTitle.value.trim(),
                composer: inputMetadataComposer.value.trim(),
                genre: inputMetadataGenre.value.trim(),
                tag: inputMetadataTag.value.trim(),
                label: inputMetadataLabel.value.trim(),
                rating: ratingValue,
                difficulty: inputMetadataDifficulty.value.trim(),
                playtime: playtimeValue,
                time: inputMetadataTime.value.trim(),
                key: inputMetadataKey.value.trim()
            };

            // Only attempt to save if any value has actually changed
            // This requires storing the current values and comparing them before sending
            // For now, simplify: if any field has focus and blur, it triggers a save.
            // A more robust solution would track actual changes or debounce.

            // For filename, it's disabled. If it were editable, it would need to be included here too
            // and handled by a specific rename API call if it changes.

            showMessage("Saving metadata changes...", 1000); // Shorter message for auto-save
            try {
                const response = await fetch(`/api/library/${selectedItemForModal.id}/metadata`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(updatedMetadata)
                });
                const result = await response.json();
                console.log("this far");
                if (response.ok) {
                    showMessage(result.message || "Metadata updated.", 1000);
                    // After saving, re-fetch library data to ensure consistency across the app
                    await fetchLibraryData();
                    renderLibraryGrid(); // Re-render the grid to show updated titles if applicable
                } else {
                    showMessage(`Error: ${result.error || 'Could not save metadata.'}`, 2000);
                }
            } catch (error) {
                console.error("Error saving metadata changes:", error);
                showMessage("Network error: Could not save metadata changes.", 2000);
            }
        }

        /**
         * Closes the song details modal.
         */
        function closeSongDetailsModal() {
            songDetailsModal.classList.remove('active');
            selectedItemForModal = null; // Clear selected item
        }

        /**
         * Switches the active tab within the song details modal.
         * @param {string} tabName - 'metadata' or 'playlists'.
         */
        async function switchSongDetailsTab(tabName) {
            // Remove active class from all tab buttons and hide all content
            metadataTabButton.classList.remove('active');
            playlistsTabButtonModal.classList.remove('active');
            metadataContent.classList.add('hidden');
            playlistsContentModal.classList.add('hidden');

            // Add active class to selected tab button and show its content
            if (tabName === 'metadata') {
                metadataTabButton.classList.add('active');
                metadataContent.classList.remove('hidden');
            } else if (tabName === 'playlists') {
                playlistsTabButtonModal.classList.add('active');
                playlistsContentModal.classList.remove('hidden');
                await populateSongPlaylists(); // Populate playlists when the tab is opened
            }
        }

        /**
         * Populates the list of playlists a song is in within the modal.
         */
        async function populateSongPlaylists() {
            songInPlaylistsList.innerHTML = '<p class="text-gray-600">Loading playlists...</p>';
            addPlaylistsDropdown.innerHTML = ''; // Clear dropdown for adding

            if (!selectedItemForModal) {
                songInPlaylistsList.innerHTML = '<p class="text-gray-600">No song selected.</p>';
                return;
            }

            try {
                // Fetch all playlists (for the 'add to' dropdown)
                await fetchPlaylistsData(); // Ensures playlistsData is up to date

                // Fetch playlists this specific song belongs to
                const response = await fetch(`/api/library/${selectedItemForModal.id}/playlists`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const songPlaylists = await response.json();

                // Display playlists the song is already in
                songInPlaylistsList.innerHTML = '';
                if (songPlaylists.length === 0) {
                    songInPlaylistsList.innerHTML = '<p class="text-gray-600">This song is not in any playlist yet.</p>';
                } else {
                    songPlaylists.forEach(playlist => {
                        const playlistItem = document.createElement('div');
                        playlistItem.className = 'playlist-item-with-remove';
                        playlistItem.innerHTML = `
                            <span>${playlist.name}</span>
                            <button data-playlist-id="${playlist.id}" class="remove-from-playlist-button">
                                <i class="fas fa-minus-circle"></i> Remove
                            </button>
                        `;
                        songInPlaylistsList.appendChild(playlistItem);

                        // Attach event listener to the remove button
                        playlistItem.querySelector('.remove-from-playlist-button').addEventListener('click', (e) => {
                            const playlistIdToRemoveFrom = parseInt(e.currentTarget.dataset.playlistId);
                            removeSongFromSpecificPlaylist(selectedItemForModal.id, playlistIdToRemoveFrom);
                        });
                    });
                }

                // Populate the "Add to Playlist" dropdown
                const playlistsToAdd = playlistsData.filter(p => !songPlaylists.some(sp => sp.id === p.id));
                if (playlistsToAdd.length === 0) {
                    addPlaylistsDropdown.innerHTML = '<button disabled class="button-disabled">No other playlists to add to.</button>';
                } else {
                    playlistsToAdd.forEach(playlist => {
                        const button = document.createElement('button');
                        button.textContent = playlist.name;
                        button.addEventListener('click', () => {
                            addPdfToPlaylist(selectedItemForModal.id, selectedItemForModal.name, playlist.id);
                            // Refresh playlists after adding
                            populateSongPlaylists();
                        });
                        addPlaylistsDropdown.appendChild(button);
                    });
                }

            } catch (error) {
                console.error("Error populating song playlists:", error);
                songInPlaylistsList.innerHTML = '<p class="text-red-500">Error loading playlists.</p>';
                addPlaylistsDropdown.innerHTML = '<button disabled class="button-disabled">Error loading playlists.</button>';
            }
        }

        /**
         * Removes a song from a specific playlist via API call.
         * @param {number} songId - The ID of the song to remove.
         * @param {number} playlistId - The ID of the playlist from which to remove the song.
         */
        async function removeSongFromSpecificPlaylist(songId, playlistId) {
            if (!confirm('Are you sure you want to remove this song from this playlist?')) {
                return;
            }
            try {
                const response = await fetch(`/api/playlists/${playlistId}/songs/${songId}`, {
                    method: 'DELETE',
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const result = await response.json();
                showMessage(result.message, 2500);
                populateSongPlaylists(); // Re-populate to reflect removal
            } catch (error) {
                console.error("Error removing song from playlist:", error);
                showMessage(`Failed to remove song from playlist: ${error.message}`, 3000);
            }
        }

        /**
         * Adds a PDF item to a specified playlist via API.
         * @param {number} itemId - The ID of the PDF item to add.
         * @param {string} itemName - The name of the PDF item to add.
         * @param {number} playlistId - The ID of the playlist to add to.
         */
        async function addPdfToPlaylist(itemId, itemName, playlistId) {
            try {
                const response = await fetch(`/api/playlists/${playlistId}/songs`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ library_item_id: itemId })
                });

                const result = await response.json();

                if (response.ok) {
                    showMessage(`"${itemName}" added to playlist.`, 2500);
                } else {
                    showMessage(`Error: ${result.error || 'Could not add song to playlist.'}`, 3000);
                }
            } catch (error) {
                console.error("Error adding PDF to playlist:", error);
                showMessage("Network error: Could not add song to playlist.", 3000);
            }
        }

        // --- Long Press for Mobile ---
        let longPressTimer;
        const LONG_PRESS_THRESHOLD = 500; // milliseconds

        function startLongPress(event, itemId, itemName) {
            // Only consider single touch
            if (event.touches.length === 1) {
                // Store the item associated with this touch
                selectedItemForModal = { id: itemId, name: itemName };
                // Set a timer to show the context menu after the threshold
                longPressTimer = setTimeout(() => {
                    // Open the modal
                    openSongDetailsModal(event, itemId, itemName);
                }, LONG_PRESS_THRESHOLD);
            }
        }

        function endLongPress() {
            clearTimeout(longPressTimer);
            // Reset selectedItemForModal if a short tap occurred without showing the menu
            // This is handled by openSongDetailsModal setting it, and closeSongDetailsModal clearing it.
        }

        /**
         * Handles the scan library action.
         */
        async function handleScanLibrary() {
            showMessage("Scanning library... This may take a moment.", 3000);
            try {
                const response = await fetch('/api/rescan_library', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                const result = await response.json();
                if (response.ok) {
                    showMessage(result.message, 2500);
                    // Re-fetch and re-render the library after successful scan
                    await fetchLibraryData();
                    currentLibraryPath = []; // Reset path to root after scan
                    saveCurrentPathToHistory();
                    renderLibraryGrid();
                } else {
                    showMessage(`Scan Error: ${result.error || 'Could not initiate scan.'}`, 4000);
                }
            } catch (error) {
                console.error("Error initiating library scan:", error);
                showMessage("Network error: Could not connect to initiate library scan.", 4000);
            }
        }

        /**
         * Handles the change library folder action.
         */
        async function handleChangeLibraryFolder() {
            optionsDropdown.classList.remove('active'); // Close main options dropdown if open

            // Fetch the current path to pre-fill the input
            try {
                const response = await fetch('/api/config/pdf_storage_path');
                if (response.ok) {
                    const data = await response.json();
                    newPathInput.value = data.path || '';
                } else {
                    newPathInput.value = ''; // Fallback to empty if fetch fails
                }
            } catch (error) {
                newPathInput.value = ''; // Fallback to empty on network error
                console.error("Could not fetch current library path:", error);
            }

            changePathModal.classList.remove('hidden');
            changePathModal.classList.add('active');
            newPathInput.focus();
        }

        /**
         * Saves the new library path from the modal.
         */
        async function saveNewLibraryPath() {
            const newPath = newPathInput.value.trim();
            if (newPath === '') {
                showMessage("Path cannot be empty.", 2000);
                return;
            }

            changePathModal.classList.remove('active');
            changePathModal.classList.add('hidden');
            showMessage("Attempting to change library folder and rescan...", 3000);

            try {
                const response = await fetch('/api/update_pdf_path', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ new_path: newPath })
                });
                const result = await response.json();
                if (!response.ok) throw new Error(result.error || 'Could not change library folder.');

                showMessage(result.message, 3000);
                await fetchLibraryData();
                currentLibraryPath = [];
                saveCurrentPathToHistory();
                renderLibraryGrid();
            } catch (error) {
                console.error("Error changing library folder:", error);
                showMessage(`Error: ${error.message}`, 5000);
            }
        }

        /**
         * Opens the share modal and generates the QR code.
         */
        async function openShareModal() {
            let serverUrl;
            try {
                // Fetch the server's actual IP address from the backend
                const response = await fetch('/api/server_address');
                if (!response.ok) {
                    throw new Error('Failed to fetch server address from API.');
                }
                const data = await response.json();
                serverUrl = data.server_address;
                if (!serverUrl) {
                    throw new Error('Server address not provided by API.');
                }
            } catch (error) {
                console.error('Error fetching server IP:', error);
                showMessage('Could not get server IP from API. Using current host.', 3000);
                serverUrl = `${window.location.protocol}//${window.location.host}`; // Fallback to current host
            }
            serverLinkInput.value = serverUrl;
            qrCodeContainer.innerHTML = ''; // Clear previous QR code
            const canvas = document.createElement('canvas');
            qrCodeContainer.appendChild(canvas);

            try {
                await QRCode.toCanvas(canvas, serverUrl, {
                    width: 220,
                    margin: 1,
                    errorCorrectionLevel: 'H'
                });
                shareModal.classList.remove('hidden');
                shareModal.classList.add('active');
            } catch (err) {
                console.error('QR Code generation failed:', err);
                showMessage('Could not generate QR code.', 3000);
            }
        }

        /**
         * Copies the server link to the clipboard.
         */
        function copyServerLink() {
            serverLinkInput.select();
            serverLinkInput.setSelectionRange(0, 99999); // For mobile devices

            try {
                navigator.clipboard.writeText(serverLinkInput.value);
                showMessage('Link copied to clipboard!', 2000);
            } catch (err) {
                showMessage('Failed to copy link.', 3000);
            }
        }

        // --- Event Listeners ---
        homeButton.addEventListener('click', () => {
            currentLibraryPath = [];
            saveCurrentPathToHistory(); // Save root path
            renderLibraryGrid();
        });
        backButton.addEventListener('click', goBackInHistory);
        forwardButton.addEventListener('click', goForwardInHistory);
        upButton.addEventListener('click', goUpOneLevel);

        // Toggle options dropdown
        optionsButton.addEventListener('click', (event) => {
            event.stopPropagation(); // Prevent document click from immediately closing it
            optionsDropdown.classList.toggle('active');
        });

        // Event listeners for sorting options inside the dropdown
        alphabeticalSortButton.addEventListener('click', (event) => {
            sortLibrary(event.target.dataset.sortOrder);
        });
        dateCreatedSortButton.addEventListener('click', (event) => {
            sortLibrary(event.target.dataset.sortOrder);
        });
        dateLastPlayedSortButton.addEventListener('click', (event) => {
            sortLibrary(event.target.dataset.sortOrder);
        });
        // New event listener for "Change Library Folder" button in options dropdown
        changeLibraryFolderButton.addEventListener('click', handleChangeLibraryFolder);

        // Change Path Modal Listeners
        closeChangePathModalButton.addEventListener('click', () => { changePathModal.classList.remove('active'); changePathModal.classList.add('hidden'); });
        cancelChangePathButton.addEventListener('click', () => { changePathModal.classList.remove('active'); changePathModal.classList.add('hidden'); });
        saveNewPathButton.addEventListener('click', saveNewLibraryPath);
        newPathInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') saveNewLibraryPath(); });

        // Share Modal Listeners
        shareButton.addEventListener('click', openShareModal);
        closeShareModalButton.addEventListener('click', () => { shareModal.classList.remove('active'); });
        copyLinkButton.addEventListener('click', copyServerLink);

        // Song Details Modal Event Listeners
        closeModalButton.addEventListener('click', closeSongDetailsModal);
        // Swapped order of tab button listeners
        playlistsTabButtonModal.addEventListener('click', () => switchSongDetailsTab('playlists'));
        metadataTabButton.addEventListener('click', () => switchSongDetailsTab('metadata'));

        // Attach blur listeners for automatic saving
        inputMetadataTitle.addEventListener('blur', saveMetadataChanges);
        inputMetadataComposer.addEventListener('blur', saveMetadataChanges);
        inputMetadataGenre.addEventListener('blur', saveMetadataChanges);
        inputMetadataTag.addEventListener('blur', saveMetadataChanges);
        inputMetadataLabel.addEventListener('blur', saveMetadataChanges);
        inputMetadataRating.addEventListener('blur', saveMetadataChanges);
        inputMetadataDifficulty.addEventListener('blur', saveMetadataChanges);
        inputMetadataPlaytime.addEventListener('blur', saveMetadataChanges);
        inputMetadataTime.addEventListener('blur', saveMetadataChanges);
        inputMetadataKey.addEventListener('blur', saveMetadataChanges);

        // Tab switching listeners
        libraryTabButton.addEventListener('click', () => switchView('library'));
        playlistsTabButton.addEventListener('click', () => switchView('playlists'));

        // Create New Playlist button
        createNewPlaylistButton.addEventListener('click', async () => {
            const playlistName = prompt("Enter a name for your new playlist:");
            if (playlistName && playlistName.trim() !== '') {
                try {
                    const response = await fetch('/api/playlists', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ name: playlistName.trim() })
                    });
                    const result = await response.json();
                    if (response.ok) {
                        showMessage(`Playlist "${result.name}" created!`, 2000);
                        await fetchPlaylistsData(); // Re-fetch all playlists to update the list
                        renderPlaylistsList();
                    } else {
                        showMessage(`Error: ${result.error || 'Could not create playlist.'}`, 3000);
                    }
                } catch (error) {
                    console.error("Error creating playlist:", error);
                    showMessage("Network error: Could not create playlist.", 3000);
                }
            } else if (playlistName !== null) {
                showMessage('Playlist name cannot be empty.', 2000);
            }
        });

        // Close dropdown/context menu when clicking anywhere else on the document
        document.addEventListener('click', (event) => {
            // Close options dropdown
            if (optionsDropdown.classList.contains('active') && !optionsDropdown.contains(event.target) && event.target !== optionsButton) {
                optionsDropdown.classList.remove('active');
            }
            // Close modal if click outside modal content and not on the modal trigger itself
            if (songDetailsModal.classList.contains('active') && !songDetailsModal.querySelector('#songDetailsModalContent').contains(event.target) && !event.target.closest('.library-grid-item.pdf')) {
                closeSongDetailsModal();
            }
            // Close change path modal
            if (changePathModal.classList.contains('active') &&
                !changePathModal.querySelector('.bg-white').contains(event.target) &&
                !event.target.closest('#changeLibraryFolderButton') &&
                !event.target.closest('#actionButton')) {
                changePathModal.classList.remove('active');
                changePathModal.classList.add('hidden');
            }
            // Close share modal
            if (shareModal.classList.contains('active') &&
                !shareModal.querySelector('.bg-white').contains(event.target) &&
                !event.target.closest('#shareButton')) {
                shareModal.classList.remove('active');
                shareModal.classList.add('hidden');
            }
        });

        // Prevent default context menu on entire body, let specific elements handle it.
        document.body.addEventListener('contextmenu', (event) => {
            // Only prevent default context menu in the library grid view.
            // This allows normal touch-and-hold behavior (like scrolling) in other areas like the playlist list.
            const libraryGrid = document.getElementById('libraryGrid');
            if (libraryGrid.contains(event.target) && !event.target.closest('.library-grid-item.pdf')) {
                // Prevent context menu on the grid background, but not on the PDF items themselves.
                event.preventDefault();
            }
        });

        // Handle window resizing to re-render grid
        window.addEventListener('resize', () => {
            if (currentView === 'library') {
                renderLibraryGrid();
            }
        });

        // Initial app setup
        // Load library data first, then switch view based on localStorage flag
        document.addEventListener('DOMContentLoaded', async () => {
            await fetchLibraryData(); // Ensure libraryData is loaded first

            const activeTabPreference = localStorage.getItem('maestroScoreActiveTab');
            if (activeTabPreference === 'playlists') {
                switchView('playlists');
                localStorage.removeItem('maestroScoreActiveTab'); // Clear the flag
            } else {
                switchView('library'); // Default to library view
            }
        });
    </script>
</body>

</html>